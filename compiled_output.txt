Compiled Text Files - Generated on 2025-01-14 22:44:07
Source Directory: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react

##########
FILE: backend/manage.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/manage.py
##########

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'aiassistant.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


==========

##########
FILE: backend/get-contents.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/get-contents.py
##########

import os

def directory_to_comma_separated_list(directory_path):
    try:
        # List all files in the specified directory
        items = os.listdir(directory_path)

        # Filter only .svg files and remove the .svg extension
        svg_files = [os.path.splitext(item)[0] for item in items if item.endswith('.svg')]

        # Convert the list of .svg files without extensions to a comma-separated string
        comma_separated_list = ', '.join(svg_files)

        return comma_separated_list
    except FileNotFoundError:
        return "The specified directory does not exist."
    except PermissionError:
        return "Permission denied to access the specified directory."
    except Exception as e:
        return f"An error occurred: {e}"

def write_to_file(file_path, content):
    try:
        with open(file_path, 'w') as file:
            file.write(content)
    except Exception as e:
        print(f"An error occurred while writing to the file: {e}")

# Example usage:
if __name__ == "__main__":
    directory_path = input("Enter the path of the directory: ")
    result = directory_to_comma_separated_list(directory_path)

    if "An error occurred" in result or "The specified directory does not exist" in result or "Permission denied" in result:
        print(result)
    else:
        file_path = 'contents.txt'
        write_to_file(file_path, result)
        print(f"The .svg files (without extensions) in the directory have been written to {file_path}")


==========

##########
FILE: backend/claudeapi.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/claudeapi.py
##########

import anthropic
import os
client = anthropic.Anthropic(
    api_key=os.getenv("ANTHROPIC_API_KEY")
)

message = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1000,
    temperature=0,
    system="You are a tasked with generating product ads social media. You are given a product name and a short description of the product. You are to generate 3 ad copies for the product.",
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Please generate the ad copies "
                }
            ]
        },{
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Product Details: name: 'Plushie', description: 'A plushie is a soft, cuddly toy made of fabric or synthetic materials. It is often used as a decorative item or as a gift for children or adults alike.'"
                }
            ]
        }
    ]
)
print(message)

==========

##########
FILE: backend/chat/__init__.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/__init__.py
##########



==========

##########
FILE: backend/chat/views.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/views.py
##########

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.http import StreamingHttpResponse
from rest_framework import generics, permissions
from .models import Chat, MessagePair, Message, SavedSystemPrompt, Project, ProjectKnowledge
from .serializers import ChatSerializer, MessageSerializer,SystemPromptSerializer, ProjectSerializer, ProjectKnowledgeSerializer
import os
import json
import boto3
from .file_handlers import handle_file_upload, get_file_contents, delete_attachment
from .models import Attachment
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import viewsets
from rest_framework.decorators import action
from .utils.token_counter import count_tokens,get_token_usage_stats
from .services.chat_service import ChatService

# Initialize Bedrock client
bedrock_runtime = boto3.client(
    service_name="bedrock-runtime",
    region_name="us-west-2",
    aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
    aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
)   
CLAUDE_35_SONNET_V1_0 = "anthropic.claude-3-5-sonnet-20240620-v1:0"
CLAUDE_35_SONNET_V2 = "anthropic.claude-3-5-sonnet-20241022-v2:0"


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def claude_chat_view(request):
    print("request", "I got a request")
    chat_service = ChatService()

    # Validate required fields
    if not request.data.get('message') and not request.FILES:
        print("error, no message or files")
        return Response(
            {'error': 'Either message or files must be provided'}, 
            status=400
        )

    try:
        # Extract request data
        chat_id = request.data.get('chat_id')
        message_text = request.data.get('message', '')
        project_id = request.data.get('project_id')
        files = request.FILES.getlist('files', [])
        system_prompt = request.data.get('system_prompt', '')
        
        # Create or get existing chat
        chat = chat_service.create_or_get_chat(request.user, chat_id, message_text, project_id)
        
        # Create message pair
        message_pair = MessagePair.objects.create(chat=chat)
        
        # Create user message with files
        for file in files:
            message_type = 'image' if file.content_type.startswith('image/') else 'file'
            message = Message.objects.create(
                message_pair=message_pair,
                role="user",
                type=message_type,
                text=message_text if message_type == 'text' else None,
                image=file if message_type == 'image' else None,
                file=file if message_type == 'file' else None,
                file_type=file.content_type
            )
        
        # Create text message if there's text content
        if message_text and not files:
            Message.objects.create(
                message_pair=message_pair,
                role="user",
                type='text',
                text=message_text
            )

        # Prepare message history with context
        messages = chat_service.prepare_message_history(chat, message_text, files)
        
        # Create request body and invoke model
        body = chat_service.create_chat_request_body(messages, chat)
        
        assistant_response_text = []
        def stream_response(response):
            for chunk in response['body']:
                chunk_data = json.loads(chunk['chunk']['bytes'].decode())
                if chunk_data['type'] == 'content_block_delta':
                    content = chunk_data['delta']['text']
                    assistant_response_text.append(content)
                    yield json.dumps({'type': 'text', 'content': content}) + '\n'
            # Save complete response
            complete_response = ''.join(assistant_response_text)
            Message.objects.create(
                message_pair=message_pair,
                role="assistant",
                text=complete_response,
                type='text'
            )
            yield json.dumps({'type': 'chat_id', 'content': str(chat.id)}) + '\n'

        response = chat_service.invoke_model(body)
        return StreamingHttpResponse(stream_response(response), content_type='text/event-stream')

    except Chat.DoesNotExist:
        return Response(
            {'error': 'Chat not found'}, 
            status=404
        )
    except ValueError as e:
        return Response(
            {'error': str(e)}, 
            status=400
        )
    except Exception as e:
        print(f"Error in claude_chat_view: {str(e)}")
        return Response(
            {'error': f'An unexpected error occurred: {str(e)}'}, 
            status=500
        )

class ChatMessagesListView(generics.ListCreateAPIView):
    serializer_class = MessageSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        chat_id = self.kwargs['chat_id']
        message_pairs = MessagePair.objects.filter(chat_id=chat_id).order_by('created_at')
        messages = []
        for pair in message_pairs:
            messages.extend(pair.messages.all())
        return messages

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        chat = Chat.objects.get(id=self.kwargs['chat_id'])
        return Response({
            'system_prompt': chat.system_prompt,
            'messages': [{
                'id': message['id'],
                'message_pair': message['message_pair'],
                'chat': chat.id,
                'hidden': message['hidden'],
                'edited_at': message['edited_at'],
                'original_text': message['original_text'],
                'role': message['role'],
                'type': message['type'],
                'content': message['text'] if message['type'] == 'text' else message['image'],
            } for message in serializer.data]
        })

    def perform_create(self, serializer):
        chat_id = self.kwargs['chat_id']
        chat = Chat.objects.get(id=chat_id)
        message_pair = MessagePair.objects.create(chat=chat)
        serializer.save(message_pair=message_pair)

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def chat_list_view(request):
    if request.method == 'GET':
        chats = Chat.objects.filter(user=request.user).order_by('-created_at')
        return Response([{'id': chat.id, 'title': chat.title} for chat in chats])
    elif request.method == 'POST':
        title = request.data.get('title', 'New Chat')
        chat = Chat.objects.create(user=request.user, title=title)
        return Response({'id': chat.id, 'title': chat.title})
    
class ChatDetailView(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = ChatSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Chat.objects.filter(user=self.request.user)

    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        data = serializer.data
        data['system_prompt'] = instance.system_prompt
        return Response(data)

class ChatListView(generics.ListCreateAPIView):
    serializer_class = ChatSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Chat.objects.filter(user=self.request.user).order_by('-created_at')

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def chat_list_view(request):
    if request.method == 'GET':
        chats = Chat.objects.filter(user=request.user).order_by('-created_at')
        return Response([{'id': chat.id, 'title': chat.title} for chat in chats])
    elif request.method == 'POST':
        title = request.data.get('title', 'New Chat')
        chat = Chat.objects.create(user=request.user, title=title)
        return Response({'id': chat.id, 'title': chat.title})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def chat_messages_view(request, chat_id):
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

    message_pairs = MessagePair.objects.filter(chat=chat).order_by('created_at')
    messages = []
    for pair in message_pairs:
        for message in pair.messages.all():
            messages.append({ 
                'role' : message.role,
                'type' : message.type,
                'text' : message.text if message.type == 'text' else None,
                'image':  message.image if message.type == 'image' else None,
                'created_at' : message.created_at
            })
    return Response(messages)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def update_chat_system_prompt(request, chat_id):
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
        chat.system_prompt = request.data.get('system_prompt', '')
        chat.save()
        return Response({'status': 'success'})
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

class SavedSystemPromptListCreateView(generics.ListCreateAPIView):
    serializer_class = SystemPromptSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return SavedSystemPrompt.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class SavedSystemPromptRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):    
    serializer_class = SystemPromptSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return SavedSystemPrompt.objects.filter(user=self.request.user)

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def update_saved_system_prompt(request, prompt_id):
    try:
        prompt = SavedSystemPrompt.objects.get(id=prompt_id, user=request.user)
        prompt.title = request.data.get('title', prompt.title)
        prompt.prompt = request.data.get('prompt', prompt.prompt)
        prompt.save()
        return Response({'status': 'success'})
    except SavedSystemPrompt.DoesNotExist:
        return Response({'error': 'Saved system prompt not found'}, status=404)
    

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def upload_file(request, chat_id):
    file = request.FILES.get('file')
    if not file:
        return Response({'error': 'No file provided'}, status=400)
    
    success = handle_file_upload(file, chat_id)
    if success:
        return Response({'message': 'File uploaded successfully'})
    else:
        return Response({'error': 'File upload failed'}, status=500)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_attachments(request, chat_id):
    attachments = Attachment.objects.filter(chat_id=chat_id)
    data = [{
        'id': attachment.id,
        'name': attachment.original_name,
        'url': attachment.file.url
    } for attachment in attachments]
    return Response(data)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_attachment_view(request, attachment_id):
    success = delete_attachment(attachment_id)
    if success:
        return Response({'message': 'Attachment deleted successfully'})
    else:
        return Response({'error': 'Failed to delete attachment'}, status=500)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_file_content(request, attachment_id):
    try:
        attachment = Attachment.objects.get(id=attachment_id)
        content = get_file_contents(attachment.file.path)
        return Response({'content': content})
    except Attachment.DoesNotExist:
        return Response({'error': 'Attachment not found'}, status=404)
    except Exception as e:
        return Response({'error': str(e)}, status=500)

class ProjectViewSet(viewsets.ModelViewSet):
    serializer_class = ProjectSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return Project.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    @action(detail=True, methods=['get'])
    def knowledge(self, request, pk=None):
        project = self.get_object()
        knowledge_items = project.knowledge_items.all()
        serializer = ProjectKnowledgeSerializer(knowledge_items, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def chats(self, request, pk=None):
        project = self.get_object()
        chats = Chat.objects.filter(project=project).order_by('-created_at')
        serializer = ChatSerializer(chats, many=True)
        return Response(serializer.data)

class ProjectKnowledgeViewSet(viewsets.ModelViewSet):
    serializer_class = ProjectKnowledgeSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return ProjectKnowledge.objects.filter(project__user=self.request.user)

    def perform_create(self, serializer):
        from .utils.token_counter import count_tokens
        content = self.request.data.get('content', '')
        token_count = count_tokens(content)
        serializer.save(token_count=token_count)

    @action(detail=True, methods=['patch'])
    def toggle(self, request, pk=None):
        knowledge = self.get_object()
        knowledge.include_in_chat = not knowledge.include_in_chat
        knowledge.save()
        return Response({'include_in_chat': knowledge.include_in_chat})

# Modify the existing chat_view to include project knowledge
def get_project_knowledge(chat):
    if not chat.project:
        return ""
    
    knowledge_items = chat.project.knowledge_items.filter(include_in_chat=True)
    if not knowledge_items:
        return ""
        
    knowledge_text = "\n\n".join([
        f"### {item.title} ###\n{item.content}"
        for item in knowledge_items
    ])
    
    return f"\nProject Knowledge:\n{knowledge_text}\n"

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_chat_token_usage(request, chat_id):
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
        stats = get_token_usage_stats(chat)
        return Response(stats)
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_project_token_usage(request, project_id):
    try:
        project = Project.objects.get(id=project_id, user=request.user)
        total_tokens = project.total_knowledge_tokens
        return Response({
            'total_tokens': total_tokens,
            'max_tokens': 160000,
            'usage_percentage': (total_tokens / 160000) * 100
        })
    except Project.DoesNotExist:
        return Response({'error': 'Project not found'}, status=404)

class ProjectChatsView(generics.ListAPIView):
    serializer_class = ChatSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        project_id = self.kwargs.get('project_id')
        return Chat.objects.filter(
            user=self.request.user,
            project_id=project_id
        ).order_by('-created_at')

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def edit_message(request, message_id):
    try:
        message = Message.objects.get(id=message_id)
        
        # Store original text if this is the first edit
        if not message.original_text:
            message.original_text = message.text
            
        message.text = request.data.get('text', message.text)
        message.token_count = count_tokens(message.text)
        message.save()
        
        # If this is a user message, remove the associated assistant message
        if message.role == 'user':
            message_pair = message.message_pair
            message_pair.messages.filter(role='assistant').delete()
            
        return Response({'status': 'success'})
    except Message.DoesNotExist:
        return Response({'error': 'Message not found'}, status=404)

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def toggle_message_pair(request, pair_id):
    try:
        message_pair = MessagePair.objects.get(id=pair_id)
        messages = message_pair.messages.all()
        hidden = request.data.get('hidden', True)
        
        for message in messages:
            message.hidden = hidden
            message.save()
            
        return Response({'status': 'success'})
    except MessagePair.DoesNotExist:
        return Response({'error': 'Message pair not found'}, status=404)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_message_pair(request, pair_id):
    try:
        message_pair = MessagePair.objects.get(id=pair_id)
        message_pair.delete()
        return Response({'status': 'success'})
    except MessagePair.DoesNotExist:
        return Response({'error': 'Message pair not found'}, status=404)

==========

##########
FILE: backend/chat/file_handlers.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/file_handlers.py
##########

import os
import zipfile
import shutil
from django.conf import settings
from django.core.files.storage import default_storage
from .models import Chat, Attachment

def handle_file_upload(file, chat_id):
    chat = Chat.objects.get(id=chat_id)
    file_name = default_storage.save(f'chat_{chat_id}/{file.name}', file)
    file_path = os.path.join(settings.MEDIA_ROOT, file_name)

    if file_name.endswith('.zip'):
        extract_path = os.path.join(settings.MEDIA_ROOT, f'chat_{chat_id}/extracted')
        with zipfile.ZipFile(file_path, 'r') as zip_ref:
            zip_ref.extractall(extract_path)
        
        for root, dirs, files in os.walk(extract_path):
            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, extract_path)
                Attachment.objects.create(
                    chat=chat,
                    file=f'chat_{chat_id}/extracted/{relative_path}',
                    original_name=file
                )
        
        os.remove(os.path.join(settings.MEDIA_ROOT, file_name))
    else:
        Attachment.objects.create(
            chat=chat,
            file=file_name,
            original_name=file.name
        )

    return True

def get_file_contents(file_path, max_chars=None):
    with open(file_path, 'r') as file:
        content = file.read(max_chars) if max_chars else file.read()
    return content

def delete_attachment(attachment_id):
    attachment = Attachment.objects.get(id=attachment_id)
    file_path = os.path.join(settings.MEDIA_ROOT, str(attachment.file))
    
    if os.path.exists(file_path):
        if os.path.isdir(file_path):
            shutil.rmtree(file_path)
        else:
            os.remove(file_path)
    
    attachment.delete()
    return True

==========

##########
FILE: backend/chat/serializers.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/serializers.py
##########

# serializers.py

from rest_framework import serializers
from .models import Chat, Message, MessagePair, SavedSystemPrompt, Project, ProjectKnowledge

class MessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message
        fields = '__all__'

class ChatSerializer(serializers.ModelSerializer):
    class Meta:
        model = Chat
        fields = ['id', 'title', 'created_at', 'system_prompt', 'project', 'user']

class SystemPromptSerializer(serializers.ModelSerializer):
    class Meta:
        model = SavedSystemPrompt
        fields = '__all__'
        read_only_fields = ['user']

class MessagePairSerializer(serializers.ModelSerializer):
    messages = MessageSerializer(many=True, read_only=True)

    class Meta:
        model = MessagePair
        fields = '__all__'

class ProjectSerializer(serializers.ModelSerializer):
    class Meta:
        model = Project
        fields = ['id', 'name', 'description', 'instructions', 'created_at', 'updated_at', 'total_knowledge_tokens']
        read_only_fields = ['created_at', 'updated_at']

class ProjectKnowledgeSerializer(serializers.ModelSerializer):
    token_count = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = ProjectKnowledge
        fields = ['id', 'project', 'content', 'title', 'include_in_chat', 
                 'token_count', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at', 'token_count']

    def validate(self, data):
        from .utils.token_counter import count_tokens
        
        content = data.get('content', '')
        project = data.get('project')
        
        # Count tokens for new content
        token_count = count_tokens(content)
        
        # Validate against project limits
        is_valid, error_message = project.validate_knowledge_tokens(token_count)
        if not is_valid:
            raise serializers.ValidationError(error_message)
            
        return data

==========

##########
FILE: backend/chat/tests.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/tests.py
##########

from django.test import TestCase

# Create your tests here.


==========

##########
FILE: backend/chat/urls.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/urls.py
##########

# chat/urls.py
from django.urls import path, include
from .views import (
    ChatListView, ChatMessagesListView, ChatDetailView, claude_chat_view,
    update_chat_system_prompt, SavedSystemPromptListCreateView,
    SavedSystemPromptRetrieveUpdateDestroyView, upload_file, get_attachments,
    delete_attachment_view, get_file_content, ProjectViewSet, ProjectKnowledgeViewSet,
    ProjectChatsView, get_chat_token_usage, edit_message, toggle_message_pair,
    delete_message_pair,
)
from rest_framework.routers import DefaultRouter

# Set up the router
router = DefaultRouter()
router.register(r'projects', ProjectViewSet, basename='project')
router.register(r'knowledge', ProjectKnowledgeViewSet, basename='knowledge')

urlpatterns = [
    # Include router URLs first
    path('', include(router.urls)),
    
    # Chat related URLs
    path('chats/', ChatListView.as_view(), name='chat-list'),
    path('chats/<int:chat_id>/messages/', ChatMessagesListView.as_view(), name='chat-messages-list'),
    path('chats/<int:pk>/', ChatDetailView.as_view(), name='chat-detail'),
    path('claude/', claude_chat_view, name='claude-chat'),
    path('chats/<int:chat_id>/system-prompt/', update_chat_system_prompt),
    
    # Message management
    path('messages/<int:message_id>/edit/', edit_message, name='edit-message'),
    path('message-pairs/<int:pair_id>/', delete_message_pair, name='delete-message-pair'),
    path('message-pairs/<int:pair_id>/toggle/', toggle_message_pair, name='toggle-message-pair'),
    
    # System prompts
    path('saved-system-prompts/', SavedSystemPromptListCreateView.as_view()),
    path('saved-system-prompts/<int:pk>/', SavedSystemPromptRetrieveUpdateDestroyView.as_view()),
    
    # File attachments
    path('chats/<int:chat_id>/upload/', upload_file, name='upload-file'),
    path('chats/<int:chat_id>/attachments/', get_attachments, name='get-attachments'),
    path('attachments/<int:attachment_id>/', delete_attachment_view, name='delete-attachment'),
    path('attachments/<int:attachment_id>/content/', get_file_content, name='get-file-content'),
    
    # Project chats
    path('projects/<int:project_id>/chats/', ProjectChatsView.as_view(), name='project-chats'),
    
    # Token usage
    path('chats/<str:chat_id>/tokens/', get_chat_token_usage, name='chat-tokens'),
]


==========

##########
FILE: backend/chat/apps.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/apps.py
##########

from django.apps import AppConfig


class ChatConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chat'


==========

##########
FILE: backend/chat/models.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/models.py
##########

from django.db import models
from django.core.exceptions import ValidationError

class Project(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    instructions = models.TextField(blank=True, null=True)
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_archived = models.BooleanField(default=False)
    
    def __str__(self):
        return self.name

    class Meta:
        ordering = ['-created_at']

    @property
    def total_knowledge_tokens(self):
        """Get total tokens used by all included knowledge items"""
        return self.knowledge_items.filter(
            include_in_chat=True
        ).aggregate(
            total=models.Sum('token_count')
        )['total'] or 0

    def validate_knowledge_tokens(self, new_token_count=0):
        """
        Validate if adding new_token_count would exceed the limit
        Returns (bool, str) - (is_valid, error_message)
        """
        current_total = self.total_knowledge_tokens
        new_total = current_total + new_token_count
        max_tokens = 160000  # 80% of context window

        if new_total > max_tokens:
            return False, f"Adding this would exceed the token limit. Current: {current_total}, New: {new_token_count}, Max: {max_tokens}"
        return True, ""

class ProjectKnowledge(models.Model):
    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name='knowledge_items')
    content = models.TextField()
    title = models.CharField(max_length=200)
    include_in_chat = models.BooleanField(default=True)
    token_count = models.IntegerField(default=0)  # Store token count for quick access
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.title} - {self.project.name}"

    class Meta:
        ordering = ['-created_at']

# Modify the Chat model to include project
class Chat(models.Model):
    uuid = models.CharField(max_length=100)
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    project = models.ForeignKey(Project, on_delete=models.SET_NULL, null=True, blank=True, related_name='chats')
    title = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    system_prompt = models.TextField(blank=True, null=True)
    is_archived = models.BooleanField(default=False)
    def __str__(self):
        return self.title

    @property
    def total_tokens(self):
        """Get total tokens used in this chat including project knowledge"""
        message_tokens = sum(
            message.token_count 
            for pair in self.message_pairs.all()
            for message in pair.messages.all()
        )
        project_tokens = self.project.total_knowledge_tokens if self.project else 0
        return message_tokens + project_tokens

class MessagePair(models.Model):
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='message_pairs')
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Message Pair for {self.chat.title} at {self.created_at}"

class Message(models.Model):
    message_pair = models.ForeignKey(MessagePair, on_delete=models.CASCADE, related_name='messages')
    ROLE_CHOICES = (
        ("user", "user"),
        ("assistant", "assistant"),
    )
    role = models.CharField(max_length=10, choices=ROLE_CHOICES)
    TYPE_CHOICES = (
        ("text", "text"),
        ("image", "image"),
        ("file", "file"),
    )
    type = models.CharField(max_length=10, choices=TYPE_CHOICES, default="text")
    text = models.TextField(blank=True, null=True)
    image = models.ImageField(upload_to='chat/images/', null=True, blank=True)
    file = models.FileField(upload_to='chat/files/', null=True, blank=True)
    file_type = models.CharField(max_length=50, blank=True, null=True)  # For storing MIME type
    token_count = models.IntegerField(default=0)
    hidden = models.BooleanField(default=False)
    edited_at = models.DateTimeField(auto_now=True, null=True)
    original_text = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    is_archived = models.BooleanField(default=False)

    def __str__(self):
        return f"{self.role} message in {self.message_pair}"

    def get_content(self):
        """Return content in the format expected by Claude API"""
        content = []
        
        # Add image if present
        if self.type == 'image' and self.image:
            import base64
            with open(self.image.path, 'rb') as img_file:
                encoded_image = base64.b64encode(img_file.read()).decode('utf-8')
                content.append({
                    'type': 'image',
                    'source': {
                        'type': 'base64',
                        'media_type': 'image/jpeg',
                        'data': encoded_image
                    }
                })
        
        # Add text content
        if self.text:
            content.append({
                'type': 'text',
                'text': self.text
            })
            
        return content

    def save(self, *args, **kwargs):
        if not self.token_count:
            from .utils.token_counter import count_tokens
            self.token_count = count_tokens(self.text)
        super().save(*args, **kwargs)

class SavedSystemPrompt(models.Model):
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    title = models.CharField(max_length=100)
    prompt = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

class Attachment(models.Model):
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='attachments')
    file = models.FileField(upload_to='chat_attachments/')
    original_name = models.CharField(max_length=255)
    uploaded_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.original_name

class TokenUsage(models.Model):
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE)
    tokens_used = models.IntegerField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.user.email} - {self.tokens_used} tokens on {self.created_at}"

==========

##########
FILE: backend/chat/services/chat_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/services/chat_service.py
##########

from typing import List, Dict, Any, Optional
import json
import boto3
import os
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractUser
from ..models import Chat, MessagePair, Message, Project, Attachment
from ..file_handlers import get_file_contents
from ..prompts.coding import get_coding_system_prompt
User = get_user_model()

class ChatService:
    CLAUDE_35_SONNET_V2 = "anthropic.claude-3-5-sonnet-20241022-v2:0"

    def __init__(self):
        self.bedrock_runtime = boto3.client(
            service_name="bedrock-runtime",
            region_name="us-west-2",
            aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
        )

    def create_or_get_chat(self, user: AbstractUser, chat_id: str, message_text: str, project_id: Optional[str] = None) -> Chat:
        if chat_id is None or chat_id == 'new':
            return self._create_new_chat(user, message_text, project_id)
        return Chat.objects.get(id=chat_id, user=user)

    def _create_new_chat(self, user: AbstractUser, message_text: str, project_id: Optional[str]) -> Chat:
        title = message_text[:15] + "..."
        project = None
        if project_id:
            project = Project.objects.get(id=project_id, user=user)
            
        # Create chat with default coding system prompt
        chat = Chat.objects.create(
            title=title, 
            user=user, 
            project=project,
            system_prompt=""
        )
        return chat

    def get_project_context(self, chat: Chat) -> str:
        if not chat.project:
            return ""

        context_parts = []
        
        if chat.project.instructions:
            context_parts.append(f"Project Instructions:\n{chat.project.instructions}")

        knowledge_items = chat.project.knowledge_items.filter(include_in_chat=True)
        if knowledge_items:
            knowledge_text = "\n\n".join([
                f"### {item.title} ###\n{item.content}"
                for item in knowledge_items
            ])
            context_parts.append(f"Project Knowledge:\n{knowledge_text}")

        return "\n\n".join(context_parts)

    def prepare_message_history(self, chat: Chat, message_text: str, attachment_ids: List[str]) -> List[Dict[str, Any]]:
        messages = []
        
        # Add project context as a separate user message if exists
        project_context = self.get_project_context(chat)
        if project_context:
            messages.append({
                'role': 'user',
                'content': [{'type': 'text', 'text': f"<project_knowledge>\n{project_context}\n</project_knowledge>"}]
            })
        
        # Build message history
        messages.extend(self._build_message_history(chat))
        
        # Add file contents if any
        file_contents = self._get_attachment_contents(attachment_ids)
        file_context = ""
        if file_contents:
            file_context = f"<file_attachments>\n{self._format_file_contents(file_contents)}\n</file_attachments>\n\n"
        
        # Add current user message with appropriate tags
        current_message = f"{file_context}<user_query>\n{message_text}\n</user_query>"
        messages.append({
            'role': 'user',
            'content': [{'type': 'text', 'text': current_message}]
        })
        
        return messages

    def _format_file_contents(self, file_contents: List[str]) -> str:
        return "\n".join(file_contents)

    def _build_message_history(self, chat: Chat) -> List[Dict[str, Any]]:
        messages = []
        for pair in MessagePair.objects.filter(chat=chat).order_by('created_at'):
            for message in pair.messages.all():
                messages.append({
                    'role': message.role,
                    'content': message.get_content()
                })
        return messages

    def _get_attachment_contents(self, attachment_ids: List[str]) -> List[str]:
        file_contents = []
        for attachment_id in attachment_ids:
            try:
                attachment = Attachment.objects.get(id=attachment_id)
                content = get_file_contents(attachment.file.path)
                file_contents.append(f"File: {attachment.original_name}\n\n{content}\n\n")
            except Attachment.DoesNotExist:
                continue
        return file_contents

    def prepare_message_content(self, message_text: str, files: List[Any]) -> List[Dict[str, Any]]:
        """Prepare message content with text and files"""
        content = []
        
        # Handle image files
        for file in files:
            if file.content_type.startswith('image/'):
                import base64
                encoded_image = base64.b64encode(file.read()).decode('utf-8')
                content.append({
                    'type': 'image',
                    'source': {
                        'type': 'base64',
                        'media_type': file.content_type,
                        'data': encoded_image
                    }
                })
        
        # Add text content
        if message_text:
            content.append({
                'type': 'text',
                'text': message_text
            })
            
        return content

    def create_chat_request_body(self, messages: List[Dict[str, Any]], chat: Chat) -> str:
        system_prompt = get_coding_system_prompt(chat.system_prompt or "")
        
        return json.dumps({
            "system": system_prompt,
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "messages": messages
        })

    def invoke_model(self, body: str):
        return self.bedrock_runtime.invoke_model_with_response_stream(
            body=body,
            modelId=self.CLAUDE_35_SONNET_V2
        ) 

==========

##########
FILE: backend/chat/utils/token_counter.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/chat/utils/token_counter.py
##########

import os
from functools import lru_cache
from transformers import GPT2TokenizerFast

tokenizer = GPT2TokenizerFast.from_pretrained("Xenova/claude-tokenizer")

def count_tokens(text: str) -> int:
    return len(tokenizer.encode(text))

def validate_token_count(text: str, max_tokens: int = 160000) -> bool:  # 80% of 200k
    """Returns True if token count is within limit"""
    token_count = count_tokens(text)
    return token_count <= max_tokens

def get_token_usage_stats(chat):
    """Get detailed token usage stats for a chat"""
    message_tokens = sum(
        message.token_count 
        for pair in chat.message_pairs.all()
        for message in pair.messages.all()
    )
    
    project_tokens = chat.project.total_knowledge_tokens if chat.project else 0
    total_tokens = message_tokens + project_tokens
    
    return {
        'message_tokens': message_tokens,
        'project_tokens': project_tokens,
        'total_tokens': total_tokens,
        'max_tokens': 200000,
        'usage_percentage': (total_tokens / 200000) * 100
    } 

==========

##########
FILE: backend/utils/generate_uid.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/utils/generate_uid.py
##########

import hashlib
import base64
import uuid

def generate_uid():
    # Generate a UUID
    uid = str(uuid.uuid4())

    # Hash the UUID using SHA-256
    hashed_uid = hashlib.sha256(uid.encode()).digest()

    # Encode the hashed UUID in base64
    short_uid = base64.urlsafe_b64encode(hashed_uid)[:8].decode()

    return short_uid



==========

##########
FILE: backend/utils/call_llm.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/utils/call_llm.py
##########

from openai import OpenAI
client = OpenAI()


def call_llm(system_message, messages):
    # the messages passed in the function are an array of strings,format the messages to be in the object that GPT-3.5-turbo API expects
    # format the messages to be in the object that GPT-3.5-turbo API expects
    formatted_messages = []
    for message in messages:
        formatted_messages.append({"role": "user", "content": message})

    # concatenate the system message to the messages,the system message is the first message in the array
    final_messages = [{"role": "system", "content": system_message}] + formatted_messages


    response = client.chat.completions.create(
    model="gpt-3.5-turbo",
    messages=final_messages,)
    return response.choices[0].message.content

==========

##########
FILE: backend/aiassistant/urls.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/aiassistant/urls.py
##########

"""
URL configuration for aiassistant project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/v1/auth/", include("appauth.urls")),
    path("api/v1/chat/", include("chat.urls")),
]

==========

##########
FILE: backend/aiassistant/settings.py
FULL PATH: /home/kelvin/coding/ai/manticeai/anthropic-claude-aws-bedrock-chat-application-django-and-react/backend/aiassistant/settings.py
##########

"""
Django settings for aiassistant project.

Generated by 'django-admin startproject' using Django 5.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""
import environ
env = environ.Env()
environ.Env.read_env()
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1',])

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "rest_framework",
    "corsheaders",
    "appauth",
    "knox",
    "chat",
    "social_django",
    "drf_spectacular",
    "storages",
]
AUTHENTICATION_BACKENDS = (
    'social_core.backends.open_id.OpenIdAuth',
    'social_core.backends.google.GoogleOAuth2',
    'social_core.backends.google.GoogleOAuth',
    'django.contrib.auth.backends.ModelBackend',
)

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware', 
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'social_django.middleware.SocialAuthExceptionMiddleware',
]
ROOT_URLCONF = 'aiassistant.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


WSGI_APPLICATION = 'aiassistant.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# rest framework configuration, with knox for token authentication
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': ('knox.auth.TokenAuthentication',),
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# auth model
AUTH_USER_MODEL = "appauth.AppUser"


SPECTACULAR_SETTINGS = {
    'TITLE': 'Mantice AI Assistant API',
    'DESCRIPTION': 'Your project description',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    # OTHER SETTINGS
}

# knox settings

from datetime import timedelta
from rest_framework.settings import api_settings

REST_KNOX = {
  'SECURE_HASH_ALGORITHM': 'cryptography.hazmat.primitives.hashes.SHA512',
  'AUTH_TOKEN_CHARACTER_LENGTH': 64,
  'TOKEN_TTL': timedelta(weeks=2),
  'USER_SERIALIZER': 'knox.serializers.UserSerializer',
  'TOKEN_LIMIT_PER_USER': None,
  'AUTO_REFRESH': True,
  'EXPIRY_DATETIME_FORMAT': api_settings.DATETIME_FORMAT,
}

BUNDLER_SERVER_URL = "http://localhost:3001"


# AWS S3 Settings
AWS_ACCESS_KEY_ID =  env('AWS_S3_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = env('AWS_S3_SECRET_ACCESS_KEY')
AWS_STORAGE_BUCKET_NAME =  env('AWS_S3_BUCKET_NAME')
AWS_S3_REGION_NAME = env('AWS_S3_BUCKET_REGION')
AWS_S3_FILE_OVERWRITE = False
AWS_DEFAULT_ACL = None
AWS_S3_VERIFY = True

# Make sure AWS_S3_CUSTOM_DOMAIN is set
AWS_S3_CUSTOM_DOMAIN = f'{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com'
# S3 Static settings
STATIC_LOCATION = 'static'
STATIC_URL = f'https://{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com/{STATIC_LOCATION}/'
STATICFILES_STORAGE = 'aiassistant.storage_backends.StaticStorage'

# S3 Media settings
PUBLIC_MEDIA_LOCATION = 'media'
MEDIA_URL = f'https://{AWS_S3_CUSTOM_DOMAIN}/{PUBLIC_MEDIA_LOCATION}/'
DEFAULT_FILE_STORAGE = 'aiassistant.storage_backends.MediaStorage'
PAYSTACK_SECRET_KEY = env('PAYSTACK_SECRET_KEY')

TOKEN_PRICE= 0.01

AWS_BEDROCK_ACCESS_KEY_ID=env("AWS_BEDROCK_ACCESS_KEY_ID")
AWS_BEDROCK_SECRET_ACCESS_KEY=env("AWS_BEDROCK_SECRET_ACCESS_KEY")

FRONTEND_URL = "http://localhost:3000"
SITE_NAME = "Mantice AI"
SUPPORT_EMAIL = env('EMAIL_USER')

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.zoho.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
EMAIL_HOST_USER = env('EMAIL_USER')
EMAIL_HOST_PASSWORD = env('EMAIL_PASSWORD')
DEFAULT_FROM_EMAIL = env('EMAIL_USER')


# CORS Settings
CORS_ALLOW_ALL_ORIGINS = False  # More secure than allowing all origins
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=[])
CORS_ALLOW_CREDENTIALS = True  # Important for sending cookies across origins

# CSRF Settings
CSRF_TRUSTED_ORIGINS = env.list('CSRF_TRUSTED_ORIGINS', default=[])
CSRF_COOKIE_SAMESITE = 'Lax'  # or 'None' if needed, but 'Lax' is more secure
CSRF_COOKIE_HTTPONLY = False  # False because we need to access it from JavaScript
SESSION_COOKIE_SAMESITE = 'Lax'  # Should match CSRF_COOKIE_SAMESITE
CSRF_COOKIE_SECURE = False  # Set to True in production with HTTPS
SESSION_COOKIE_SECURE = False  # Set to True in production with HTTPS

# Cookie settings
CSRF_COOKIE_NAME = 'csrftoken'  # Default value, but good to be explicit




==========
