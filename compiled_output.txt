Compiled Text Files - Generated on 2025-05-23 15:48:17
Source Directory: /home/kelvin/coding/ai/manticeai/myclaude

##########
FILE: backend/manage.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/manage.py
##########

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'aiassistant.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


==========

##########
FILE: backend/get-contents.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/get-contents.py
##########

import os

def directory_to_comma_separated_list(directory_path):
    try:
        # List all files in the specified directory
        items = os.listdir(directory_path)

        # Filter only .svg files and remove the .svg extension
        svg_files = [os.path.splitext(item)[0] for item in items if item.endswith('.svg')]

        # Convert the list of .svg files without extensions to a comma-separated string
        comma_separated_list = ', '.join(svg_files)

        return comma_separated_list
    except FileNotFoundError:
        return "The specified directory does not exist."
    except PermissionError:
        return "Permission denied to access the specified directory."
    except Exception as e:
        return f"An error occurred: {e}"

def write_to_file(file_path, content):
    try:
        with open(file_path, 'w') as file:
            file.write(content)
    except Exception as e:
        print(f"An error occurred while writing to the file: {e}")

# Example usage:
if __name__ == "__main__":
    directory_path = input("Enter the path of the directory: ")
    result = directory_to_comma_separated_list(directory_path)

    if "An error occurred" in result or "The specified directory does not exist" in result or "Permission denied" in result:
        print(result)
    else:
        file_path = 'contents.txt'
        write_to_file(file_path, result)
        print(f"The .svg files (without extensions) in the directory have been written to {file_path}")


==========

##########
FILE: backend/claudeapi.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/claudeapi.py
##########

import anthropic
import os
client = anthropic.Anthropic(
    api_key=os.getenv("ANTHROPIC_API_KEY")
)

message = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1000,
    temperature=0,
    system="You are a tasked with generating product ads social media. You are given a product name and a short description of the product. You are to generate 3 ad copies for the product.",
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Please generate the ad copies "
                }
            ]
        },{
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Product Details: name: 'Plushie', description: 'A plushie is a soft, cuddly toy made of fabric or synthetic materials. It is often used as a decorative item or as a gift for children or adults alike.'"
                }
            ]
        }
    ]
)
print(message)

==========

##########
FILE: backend/test_memory_integration.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/test_memory_integration.py
##########

#!/usr/bin/env python
"""
Test script to verify memory integration in chat
"""
import os
import django
import json

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'aiassistant.settings')
django.setup()

from django.contrib.auth import get_user_model
from chat.models import Chat, UserMemory, MemoryTag
from chat.services.chat_service import ChatService
from chat.services.memory_service import MemoryExtractionService

User = get_user_model()

def test_memory_integration():
    print("Testing memory integration...")
    
    # Get or create a test user
    user, created = User.objects.get_or_create(
        username='test_user',
        defaults={'email': 'test@example.com'}
    )
    
    # Create a test chat first (required for UserMemory)
    chat = Chat.objects.create(
        user=user,
        title="Test Chat",
        system_prompt=""
    )
    
    # Create some test memories
    memory_service = MemoryExtractionService()
    
    # Create a test memory
    memory1 = UserMemory.objects.create(
        user=user,
        chat=chat,  # Now we include the chat reference
        summary="User is a Python developer working on AI projects",
        raw_content="I'm a Python developer and I've been working on AI and machine learning projects for the past 3 years.",
        confidence_score=0.9,
        category="work",
        is_active=True
    )
    
    # Add tags
    tag1, _ = MemoryTag.objects.get_or_create(name="python", defaults={'color': '#3776ab'})
    tag2, _ = MemoryTag.objects.get_or_create(name="ai", defaults={'color': '#ff6b6b'})
    memory1.tags.add(tag1, tag2)
    
    memory2 = UserMemory.objects.create(
        user=user,
        chat=chat,  # Now we include the chat reference
        summary="User prefers clean, well-documented code",
        raw_content="I always prefer clean, well-documented code that follows best practices.",
        confidence_score=0.8,
        category="preferences",
        is_active=True
    )
    
    tag3, _ = MemoryTag.objects.get_or_create(name="coding", defaults={'color': '#4ecdc4'})
    memory2.tags.add(tag3)
    
    print(f"Created {UserMemory.objects.filter(user=user).count()} test memories")
    
    # Test memory retrieval
    test_message = "Can you help me write a Python function?"
    relevant_memories = memory_service.get_relevant_memories_for_context(
        user=user,
        current_message=test_message,
        limit=5
    )
    
    print(f"Found {len(relevant_memories)} relevant memories for message: '{test_message}'")
    for memory in relevant_memories:
        print(f"  - {memory.summary} (confidence: {memory.confidence_score})")
    
    # Test chat service integration
    chat_service = ChatService()
    messages = chat_service.prepare_message_history(chat, test_message)
    
    print(f"\nPrepared {len(messages)} messages for Claude")
    for i, msg in enumerate(messages):
        content_text = ""
        if isinstance(msg.get('content'), list) and len(msg['content']) > 0:
            content_text = msg['content'][0].get('text', '')[:100] + "..."
        print(f"  {i+1}. {msg['role']}: {content_text}")
    
    # Test memory formatting
    memory_context = memory_service.format_memories_for_context(relevant_memories)
    print(f"\nFormatted memory context:\n{memory_context[:200]}...")
    
    print("\nâœ… Memory integration test completed successfully!")

if __name__ == "__main__":
    test_memory_integration() 

==========

##########
FILE: backend/appauth/__init__.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/__init__.py
##########



==========

##########
FILE: backend/appauth/views.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/views.py
##########

from django.utils.translation import gettext as _
from rest_framework import generics, status
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.views import APIView
from rest_framework.exceptions import ValidationError, AuthenticationFailed
from drf_spectacular.utils import extend_schema, OpenApiResponse
from knox.models import AuthToken
from typing import Any
import logging
from .serializers import (
    RegisterSerializer,
    LoginSerializer,
    UserSerializer,
    PasswordResetRequestSerializer,
    PasswordResetConfirmSerializer,
    PasswordChangeSerializer,
    EmailVerificationSerializer,
    ResendVerificationSerializer,
    GoogleAuthSerializer
)
from .services.auth_service import (
    AuthService,
    AuthenticationError,
    RegistrationError
)
from .services.rate_limit_service import RateLimitService
from .models import AppUser

from social_django.utils import load_strategy, load_backend
from social_core.backends.oauth import BaseOAuth2
from social_core.exceptions import MissingBackend, AuthTokenError
from knox.models import AuthToken
from django.conf import settings
from rest_framework import status
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from social_core.backends.oauth import BaseOAuth2
from rest_framework import status
from rest_framework.response import Response
from knox.models import AuthToken
from rest_framework import status
from rest_framework.response import Response
from knox.models import AuthToken
from django.utils.decorators import method_decorator
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework import status
from knox.models import AuthToken
from .serializers import UserSerializer
import logging

logger = logging.getLogger(__name__)

class RegisterView(generics.CreateAPIView):
    """
    Register a new user account.
    
    Creates a new user account and sends a verification email.
    Rate limited to prevent abuse.
    """
    
    permission_classes = [AllowAny]
    serializer_class = RegisterSerializer
    
    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()
        self.rate_limiter = RateLimitService()

    @extend_schema(
        responses={
            201: OpenApiResponse(
                description="User registered successfully",
                response=UserSerializer
            ),
            429: OpenApiResponse(
                description="Too many registration attempts"
            )
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle user registration."""
        try:
            # Get client IP
            ip_address = request.META.get('REMOTE_ADDR')
            
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'registration'
            ):
                return Response(
                    {'detail': _("Too many registration attempts. Please try again later.")},
                    status=status.HTTP_429_TOO_MANY_REQUESTS
                )

            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Register user
            user = self.auth_service.register_user(
                ip_address=ip_address,
                **serializer.validated_data
            )

            token = AuthToken.objects.create(user)[1]

            # Return response
            return Response({
                'user': UserSerializer(user).data,
                'token': token
            }, status=status.HTTP_201_CREATED)

        except RegistrationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except ValidationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception    as e:
            logger.error(
                "Registration failed",
                extra={
                    'error': str(e),
                    'ip_address': ip_address
                },
                exc_info=True
            )
            return Response(
                {'detail': _("Registration failed. Please try again later.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
class LoginView(generics.GenericAPIView):
    permission_classes = [AllowAny]
    serializer_class = LoginSerializer

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.auth_service = AuthService()
        self.rate_limiter = RateLimitService()

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle user login."""
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get client IP
            ip_address = request.META.get('REMOTE_ADDR')

            try:
                # Attempt login
                user, requires_verification = self.auth_service.login_user(
                    email=serializer.validated_data['email'],
                    password=serializer.validated_data['password'],
                    ip_address=ip_address,
                    device_info=serializer.validated_data.get('device_info')
                )

                # Create auth token
                token = AuthToken.objects.create(user)[1]  # Get the token string from the tuple

                response_data = {
                    'user': UserSerializer(user).data,
                    'token': token,
                }

                if requires_verification:
                    response_data.update({
                        'requires_verification': True,
                        'message': str(_("Please verify your email to continue"))
                    })

                return Response(response_data)

            except AuthenticationFailed as e:
                return Response({
                    'error': 'authentication_failed',
                    'detail': str(e)
                }, status=status.HTTP_401_UNAUTHORIZED)

        except ValidationError as e:
            return Response({
                'error': 'validation_error',
                'detail': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:
            logger.error(
                "Login failed",
                extra={
                    'error': str(e),
                    'ip_address': ip_address
                },
                exc_info=True
            )
            return Response({
                'error': 'server_error',
                'detail': str(_("An unexpected error occurred"))
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class EmailVerificationView(generics.GenericAPIView):
    """
    Verify user's email address.
    
    Verifies the email using the token sent to user's email.
    """
    
    permission_classes = [AllowAny]
    serializer_class = EmailVerificationSerializer

    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()

    @extend_schema(
        responses={
            200: OpenApiResponse(description="Email verified successfully"),
            400: OpenApiResponse(description="Invalid verification token")
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle email verification."""
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Verify email
            if self.auth_service.verify_email(
                email=serializer.validated_data['email'],
                token=serializer.validated_data['token']
            ):
                return Response({'detail': _("Email verified successfully.")})
            
            return Response(
                {'detail': _("Invalid verification token.")},
                status=status.HTTP_400_BAD_REQUEST
            )

        except ValidationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(
                "Email verification failed",
                extra={'error': str(e)},
                exc_info=True
            )
            return Response(
                {'detail': _("Verification failed. Please try again later.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class ResendVerificationView(generics.GenericAPIView):
    """
    Resend email verification link.
    
    Sends a new verification email. Rate limited to prevent abuse.
    """
    
    permission_classes = [AllowAny]
    serializer_class = ResendVerificationSerializer

    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()
        self.rate_limiter = RateLimitService()

    @extend_schema(
        responses={
            200: OpenApiResponse(description="Verification email sent"),
            429: OpenApiResponse(description="Too many requests")
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle resending verification email."""
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'verification_email'
            ):
                return Response(
                    {'detail': _("Too many requests. Please try again later.")},
                    status=status.HTTP_429_TOO_MANY_REQUESTS
                )

            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Resend verification email
            self.auth_service.resend_verification_email(
                email=serializer.validated_data['email'],
                ip_address=ip_address
            )

            return Response({'detail': _("Verification email sent successfully.")})

        except ValidationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(
                "Failed to resend verification email",
                extra={
                    'error': str(e),
                    'ip_address': ip_address
                },
                exc_info=True
            )
            return Response(
                {'detail': _("Failed to send verification email. Please try again later.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class PasswordResetRequestView(generics.GenericAPIView):
    """
    Request password reset.
    
    Sends a password reset email. Rate limited to prevent abuse.
    """
    
    permission_classes = [AllowAny]
    serializer_class = PasswordResetRequestSerializer

    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()
        self.rate_limiter = RateLimitService()

    @extend_schema(
        responses={
            200: OpenApiResponse(description="Password reset email sent"),
            429: OpenApiResponse(description="Too many requests")
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle password reset request."""
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'password_reset'
            ):
                return Response(
                    {'detail': _("Too many requests. Please try again later.")},
                    status=status.HTTP_429_TOO_MANY_REQUESTS
                )

            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Initiate password reset
            self.auth_service.initiate_password_reset(
                email=serializer.validated_data['email'],
                ip_address=ip_address
            )

            return Response({
                'detail': _("If an account exists with this email, "
                          "a password reset link has been sent.")
            })

        except ValidationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(
                "Password reset request failed",
                extra={
                    'error': str(e),
                    'ip_address': ip_address
                },
                exc_info=True
            )
            return Response(
                {'detail': _("Failed to process request. Please try again later.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class PasswordResetConfirmView(generics.GenericAPIView):
    """
    Confirm password reset.
    
    Resets the user's password using the token from email.
    """
    
    permission_classes = [AllowAny]
    serializer_class = PasswordResetConfirmSerializer

    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()

    @extend_schema(
        responses={
            200: OpenApiResponse(description="Password reset successful"),
            400: OpenApiResponse(description="Invalid reset token")
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle password reset confirmation."""
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Reset password
            if self.auth_service.reset_password(
                email=serializer.validated_data['email'],
                token=serializer.validated_data['token'],
                new_password=serializer.validated_data['new_password'],
                ip_address=request.META.get('REMOTE_ADDR')
            ):
                return Response({'detail': _("Password reset successful.")})

            return Response(
                {'detail': _("Invalid or expired reset token.")},
                status=status.HTTP_400_BAD_REQUEST
            )

        except ValidationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(
                "Password reset confirmation failed",
                exc_info=True
            )
            return Response(
                {'detail': _("Password reset failed. Please try again.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class PasswordChangeView(generics.GenericAPIView):
    """
    Change user password.
    
    Changes the password for an authenticated user.
    """
    
    permission_classes = [IsAuthenticated]
    serializer_class = PasswordChangeSerializer

    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()

    @extend_schema(
        responses={
            200: OpenApiResponse(description="Password changed successfully"),
            400: OpenApiResponse(description="Invalid password")
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle password change."""
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Change password
            if self.auth_service.change_password(
                user=request.user,
                current_password=serializer.validated_data['current_password'],
                new_password=serializer.validated_data['new_password'],
                ip_address=request.META.get('REMOTE_ADDR')
            ):
                return Response({'detail': _("Password changed successfully.")})

            return Response(
                {'detail': _("Current password is incorrect.")},
                status=status.HTTP_400_BAD_REQUEST
            )

        except ValidationError as e:
            return Response(
                {'detail': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(
                "Password change failed",
                extra={'user_id': str(request.user.id)},
                exc_info=True
            )
            return Response(
                {'detail': _("Password change failed. Please try again.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class LogoutView(APIView):
    """
    Log out user.
    
    Invalidates the current auth token.
    """
    
    permission_classes = [IsAuthenticated]

    def __init__(self, **kwargs: Any) -> None:
        """Initialize view with required services."""
        super().__init__(**kwargs)
        self.auth_service = AuthService()

    @extend_schema(
        responses={
            200: OpenApiResponse(description="Logged out successfully")
        }
    )
    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle user logout."""
        try:
            # Log out user
            self.auth_service.logout_user(
                user=request.user,
                all_sessions=request.data.get('all_sessions', False),
                ip_address=request.META.get('REMOTE_ADDR')
            )
            
            return Response({'detail': _("Logged out successfully.")})

        except Exception as e:
            logger.error(
                "Logout failed",
                extra={'user_id': str(request.user.id)},
                exc_info=True
            )
            return Response(
                {'detail': _("Logout failed. Please try again.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        
from django.views.decorators.csrf import csrf_exempt

import requests

@method_decorator(csrf_exempt, name='dispatch')
class GoogleAuthView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request, *args, **kwargs):
        try:
            access_token = request.data.get('access_token')
            if not access_token:
                return Response(
                    {'error': 'Access token is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Verify token with Google
            google_response = requests.get(
                'https://www.googleapis.com/oauth2/v3/userinfo',
                headers={'Authorization': f'Bearer {access_token}'}
            )
            google_response.raise_for_status()
            user_data = google_response.json()

            # Get or create user
            from django.contrib.auth import get_user_model
            User = get_user_model()
            
            try:
                user = User.objects.get(email=user_data['email'])
            except User.DoesNotExist:
                # Create new user
                user = User.objects.create_user(
                    email=user_data['email'],
                    first_name=user_data.get('given_name', ''),
                    last_name=user_data.get('family_name', ''),
                    password=None  # Password not needed for OAuth
                )
                user.email_verified = True  # Google has verified the email
                user.save()
            
            # Create auth token
            from knox.models import AuthToken
            _, token = AuthToken.objects.create(user)
            
            return Response({
                'user': {
                    'id': str(user.id),
                    'email': user.email,
                    'first_name': user.first_name,
                    'last_name': user.last_name,
                    'email_verified': user.email_verified,
                },
                'token': token
            })

        except requests.exceptions.RequestException as e:
            logger.error(f"Google API error: {str(e)}")
            return Response(
                {'error': 'Failed to verify Google token'},
                status=status.HTTP_400_BAD_REQUEST
            )
            
        except Exception as e:
            logger.error(f"Google auth error: {str(e)}")
            return Response(
                {'error': 'Authentication failed'},
                status=status.HTTP_400_BAD_REQUEST
            )
    
class UserProfileView(generics.RetrieveUpdateAPIView):
    """
    Get or update user profile.
    
    Allows authenticated users to view and update their profile information.
    """
    
    permission_classes = [IsAuthenticated]
    serializer_class = UserSerializer

    def get_object(self) -> AppUser:
        """Get the user profile."""
        return self.request.user

    @extend_schema(
        responses={
            200: UserSerializer,
            400: OpenApiResponse(description="Invalid data")
        }
    )
    def patch(self, request, *args: Any, **kwargs: Any) -> Response:
        """Handle partial profile update."""
        try:
            return super().patch(request, *args, **kwargs)
        except Exception as e:
            logger.error(
                "Profile update failed",
                extra={
                    'user_id': str(request.user.id),
                    'error': str(e)
                },
                exc_info=True
            )
            return Response(
                {'detail': _("Profile update failed. Please try again.")},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

==========

##########
FILE: backend/appauth/serializers.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/serializers.py
##########

from rest_framework import serializers
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from django.utils.translation import gettext as _
from .models import AppUser
import re

class UserSerializer(serializers.ModelSerializer):
    """Serializer for user profile data."""
    
    class Meta:
        model = AppUser
        fields = [
            'id', 'email', 'first_name', 'last_name',
            'avatar', 'email_verified', 'date_joined',
            'last_login'
        ]
        read_only_fields = [
            'id', 'email', 'email_verified',
            'date_joined', 'last_login'
        ]

class RegisterSerializer(serializers.Serializer):
    """Serializer for user registration."""
    
    email = serializers.EmailField(required=True)
    password = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )
    first_name = serializers.CharField(
        required=False,
        allow_blank=True,
        max_length=30
    )
    last_name = serializers.CharField(
        required=False,
        allow_blank=True,
        max_length=150
    )

    def validate_email(self, value):
        """Validate email address."""
        normalized_email = value.lower()
        
        # Check if email already exists
        if AppUser.objects.filter(email=normalized_email).exists():
            raise serializers.ValidationError(
                _("A user with this email already exists.")
            )
            
        # Additional email validation (e.g., domain blacklist)
        domain = normalized_email.split('@')[1]
        if domain in ['tempmail.com', 'throwaway.com']:  # Example domains
            raise serializers.ValidationError(
                _("This email domain is not allowed.")
            )
            
        return normalized_email

    def validate_password(self, value):
        """Validate password strength."""
        try:
            # Use Django's password validation
            validate_password(value)
        except ValidationError as e:
            raise serializers.ValidationError(list(e.messages))

        # Additional custom password validation
        if len(value) < 8:
            raise serializers.ValidationError(
                _("Password must be at least 8 characters long.")
            )
            
        if not re.search(r'[A-Z]', value):
            raise serializers.ValidationError(
                _("Password must contain at least one uppercase letter.")
            )
            
        if not re.search(r'[a-z]', value):
            raise serializers.ValidationError(
                _("Password must contain at least one lowercase letter.")
            )
            
        if not re.search(r'\d', value):
            raise serializers.ValidationError(
                _("Password must contain at least one number.")
            )
            
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', value):
            raise serializers.ValidationError(
                _("Password must contain at least one special character.")
            )

        return value

    def validate(self, attrs):
        """Validate the entire registration data."""
        if attrs['password'] != attrs.pop('password_confirm'):
            raise serializers.ValidationError({
                'password_confirm': _("Passwords do not match.")
            })
            
        return attrs

    def create(self, validated_data):
        """Create a new user."""
        return AppUser.objects.create_user(**validated_data)

class LoginSerializer(serializers.Serializer):
    """Serializer for user login."""
    
    email = serializers.EmailField(
        required=True,
        error_messages={
            'required': _('Email is required'),
            'invalid': _('Enter a valid email address')
        }
    )
    password = serializers.CharField(
        write_only=True,
        required=True,
        error_messages={
            'required': _('Password is required')
        },
        style={'input_type': 'password'}
    )
    device_info = serializers.JSONField(required=False)

    def validate_email(self, value):
        """Normalize email address."""
        return value.lower().strip()

    def validate(self, attrs):
        """Validate the entire login data."""
        # Add any additional validation here
        return attrs

class PasswordResetRequestSerializer(serializers.Serializer):
    """Serializer for password reset request."""
    
    email = serializers.EmailField(required=True)

    def validate_email(self, value):
        """Normalize email address."""
        return value.lower()

class PasswordResetConfirmSerializer(serializers.Serializer):
    """Serializer for password reset confirmation."""
    
    token = serializers.CharField(required=True)
    email = serializers.EmailField(required=True)
    new_password = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )
    new_password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    def validate_email(self, value):
        """Normalize email address."""
        return value.lower()

    def validate_new_password(self, value):
        """Validate new password strength."""
        try:
            validate_password(value)
        except ValidationError as e:
            raise serializers.ValidationError(list(e.messages))
        return value

    def validate(self, attrs):
        """Validate password confirmation."""
        if attrs['new_password'] != attrs['new_password_confirm']:
            raise serializers.ValidationError({
                'new_password_confirm': _("Passwords do not match.")
            })
        return attrs

class PasswordChangeSerializer(serializers.Serializer):
    """Serializer for password change."""
    
    current_password = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )
    new_password = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )
    new_password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    def validate_new_password(self, value):
        """Validate new password strength."""
        user = self.context['request'].user
        
        try:
            validate_password(value, user)
        except ValidationError as e:
            raise serializers.ValidationError(list(e.messages))

        if value == self.initial_data.get('current_password'):
            raise serializers.ValidationError(
                _("New password must be different from current password.")
            )
            
        return value

    def validate(self, attrs):
        """Validate password confirmation."""
        if attrs['new_password'] != attrs['new_password_confirm']:
            raise serializers.ValidationError({
                'new_password_confirm': _("Passwords do not match.")
            })
        return attrs

class EmailVerificationSerializer(serializers.Serializer):
    """Serializer for email verification."""
    
    token = serializers.CharField(required=True)
    email = serializers.EmailField(required=True)

    def validate_email(self, value):
        """Normalize email address."""
        return value.lower()

class ResendVerificationSerializer(serializers.Serializer):
    """Serializer for resending verification email."""
    
    email = serializers.EmailField(required=True)

    def validate_email(self, value):
        """Normalize email and check if user exists."""
        email = value.lower()
        
        try:
            user = AppUser.objects.get(email=email)
            if user.email_verified:
                raise serializers.ValidationError(
                    _("This email is already verified.")
                )
        except AppUser.DoesNotExist:
            raise serializers.ValidationError(
                _("No user found with this email address.")
            )
            
        return email

class GoogleAuthSerializer(serializers.Serializer):
    """Serializer for Google OAuth authentication."""
    access_token = serializers.CharField(required=True)
    id_token = serializers.CharField(required=False, allow_blank=True)

    def validate_access_token(self, value):
        if not value:
            raise serializers.ValidationError("Access token is required")
        return value

==========

##########
FILE: backend/appauth/tests.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/tests.py
##########

from django.test import TestCase

# Create your tests here.


==========

##########
FILE: backend/appauth/urls.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/urls.py
##########

from django.urls import path,include
from rest_framework.urlpatterns import format_suffix_patterns
from . import views

app_name = 'appauth'

urlpatterns = [
    # Registration and authentication
    path('register/', 
         views.RegisterView.as_view(), 
         name='register'),
    
    path('login/',
         views.LoginView.as_view(),
         name='login'),
    
       path('login/google/', views.GoogleAuthView.as_view(), name='google-auth'),

    
    path('logout/',
         views.LogoutView.as_view(),
         name='logout'),
    
    # Email verification
    path('verify-email/',
         views.EmailVerificationView.as_view(),
         name='verify-email'),
    
    path('verify-email/resend/',
         views.ResendVerificationView.as_view(),
         name='resend-verification'),
    
    # Password management
    path('password/reset/',
         views.PasswordResetRequestView.as_view(),
         name='password-reset-request'),
    
    path('password/reset/confirm/',
         views.PasswordResetConfirmView.as_view(),
         name='password-reset-confirm'),
    
    path('password/change/',
         views.PasswordChangeView.as_view(),
         name='password-change'),
    
    # User profile
    path('profile/',
         views.UserProfileView.as_view(),
         name='profile'),
]

# Add support for format suffixes (e.g., .json)
# urlpatterns = format_suffix_patterns(urlpatterns)

==========

##########
FILE: backend/appauth/reset-password.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/reset-password.py
##########

# # from stream_chat import StreamChat
# from datetime import datetime
# # from api.emails.PasswordResetEmail import CreatePasswordResetOtpEmail

# # from api.emails.SuccessfulPasswordReset import SuccessfulPasswordResetHtmlEmail
# # from ..serializers import *
# from rest_framework.response import Response
# from rest_framework import status
# from ..models import *

# from django.contrib.auth.models import User
# from django.conf import settings
# from django.core.mail import send_mail
# from rest_framework.decorators import api_view
# import pyotp
# from api.emails.elements import logo, styles
# from api.emails.elements import OtpMessage, SuccessfulPasswordResetEmail, logo, styles


# @api_view(['POST'])
# def request_reset_password(request):
#     """reset_password with email, OTP and new password"""
#     data = request.data
#     print(data["email"])
#     try:
#         user = User.objects.get(email=data['email'])
#     except:
#         return Response({"detail": "Sorry we couldnt find a user with such an email"}, status=status.HTTP_404_NOT_FOUND)
#     secret = pyotp.random_base32()
#     totp = pyotp.TOTP(secret).now()
#     try:
#         ds = UserOTP.objects.get(user=user)
#     except Exception as e:
#         ds = UserOTP.objects.create(user=user, otp=totp)
#     timedelta = datetime.now()-ds.timestamp.replace(tzinfo=None)
#     if timedelta.seconds < 120:
#         print(timedelta.seconds)
#         return Response({"detail": "Please wait for 120 seconds before requesting another otp"}, status=status.HTTP_429_TOO_MANY_REQUESTS)
#     ds.otp = totp
#     ds.save()

#     html_email = CreatePasswordResetOtpEmail(totp, user.username)
#     plain_text_email = OtpMessage(user.username, totp, False)
#     email_from = settings.EMAIL_HOST_USER
#     recipient_list = [data['email']]
#     try:
#         send_mail("Password reset OTP", plain_text_email,
#                   email_from, recipient_list, html_message=html_email)
#         return Response("sent a Password reset Email to the email you entered", status=status.HTTP_202_ACCEPTED)
#     except Exception as e:
#         return Response({"detail": "Trouble sending the email"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# @api_view(['POST'])
# def verify_otp(request):
#     """reset_password with email, OTP and new password"""
#     data = request.data
#     if data['email'] != '':
#         try:
#             user = User.objects.get(email=data['email'])
#             saved_otp = UserOTP.objects.get(user=user).otp
#             if user.is_active:
#                 # Check if otp is valid
#                 if data['otp'] == saved_otp:
#                     return Response({"detail": "Otp has been verified"}, status=status.HTTP_202_ACCEPTED)
#         except Exception as e:
#             return Response({"detail": "Sorry we couldnt find a user with such an email"}, status=status.HTTP_404_NOT_FOUND)
#     else:
#        return Response({"detail": "email field is needed"},
#                        status=status.HTTP_206_PARTIAL_CONTENT)


# @api_view(['POST'])
# def reset_password(request):
#     """reset_password with email, OTP and new password"""
#     data = request.data
#     if data['email'] != '':
#         try:
#             user = User.objects.get(email=data['email'])
#         except Exception as e:
#             return Response({"detail": "Could not find such an email address", "error": e.__str__()}, status=status.HTTP_400_BAD_REQUEST)
#         email_otp = data['otp']
#         new_password = data['new_password']
#         saved_otp = UserOTP.objects.get(user=user).otp
#         saved_otp_object = UserOTP.objects.get(user=user)
#         if user.is_active:
#             # Check if otp is valid
#             if data['otp'] == saved_otp:
#                 if new_password != '':
#                     # Change Password
#                     user.set_password(data['new_password'])
#                     user.save()
#                     saved_otp_object.delete()
#                     # Here user otp will also be changed on save automatically
#                     email_from = settings.EMAIL_HOST_USER
#                     recipient_list = [user.email]
#                     try:
#                         send_mail("Successfully reset your password", f"Hi {user.username}, You Successfully reset your password",
#                                   email_from, recipient_list, html_message=SuccessfulPasswordResetHtmlEmail(user.username))
#                     except Exception as e:
#                         print(e)
#                     return Response({"detail": 'Successfully changed your password '}, status=status.HTTP_201_CREATED)
#                 else:
#                     message = {
#                         'detail': 'Password cant be empty'}
#                     return Response(message, status=status.HTTP_400_BAD_REQUEST)
#             else:
#                 message = {
#                     'detail': 'OTP did not match'}
#                 return Response(message, status=status.HTTP_400_BAD_REQUEST)
#         else:
#             message = {
#                 'detail': 'Something went wrong'}
#             return Response(message, status=status.HTTP_400_BAD_REQUEST)


==========

##########
FILE: backend/appauth/apps.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/apps.py
##########

from django.apps import AppConfig


class AppauthConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'appauth'


==========

##########
FILE: backend/appauth/welcome.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/welcome.py
##########

def createWelcomeEmail():
    return "Welcome to DissolveAI!"

==========

##########
FILE: backend/appauth/models.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/models.py
##########

import uuid
from django.db import models
from django.contrib.auth.models import AbstractUser, BaseUserManager
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
import secrets


class UserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        """Create and save a regular user."""
        if not email:
            raise ValueError(_('Users must have an email address'))
        
        # Normalize email
        email = self.normalize_email(email)
        
        # Generate username only if not provided in extra_fields
        if 'username' not in extra_fields:
            username = self.generate_unique_username(email)
            extra_fields['username'] = username
        
        # Set defaults for regular users
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        
        # Create user instance
        user = self.model(email=email, **extra_fields)
        
        if password:
            user.set_password(password)
        else:
            user.set_unusable_password()
            
        try:
            user.full_clean()
        except ValidationError as e:
            raise ValueError(str(e))
            
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        """Create and save a superuser."""
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('email_verified', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError(_('Superuser must have is_staff=True.'))
        if extra_fields.get('is_superuser') is not True:
            raise ValueError(_('Superuser must have is_superuser=True.'))

        return self.create_user(email, password, **extra_fields)

    def generate_unique_username(self, email):
        """Generate a unique username from email."""
        # Get the part before @ and remove special characters
        base = email.split('@')[0].lower()
        base = ''.join(e for e in base if e.isalnum())
        
        # If base is too short, pad it
        if len(base) < 3:
            base = base + 'user'
            
        username = base
        counter = 1
        
        # Keep trying until we find a unique username
        while self.filter(username=username).exists():
            username = f"{base}{counter}"
            counter += 1
            
        return username


class AppUser(AbstractUser):
    """
    Custom user model that uses email for authentication.
    
    Attributes:
        id (UUIDField): Primary key
        email (EmailField): User's email address (unique)
        username (CharField): Auto-generated username
        email_verified (BooleanField): Whether email has been verified
        email_verification_token (CharField): Token for email verification
        email_verification_sent_at (DateTimeField): When verification email was sent
        password_reset_token (CharField): Token for password reset
        password_reset_sent_at (DateTimeField): When password reset email was sent
        last_login_ip (GenericIPAddressField): IP address of last login
        login_attempts (IntegerField): Number of failed login attempts
        locked_until (DateTimeField): Account locked until this time
        avatar (ImageField): User's profile picture
        is_active (BooleanField): Whether this user account is active
    """
    
    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
        help_text=_("Unique identifier for the user")
    )
    
    email = models.EmailField(
        _('email address'),
        unique=True,
        error_messages={
            'unique': _("A user with that email already exists."),
        }
    )
    
    username = models.CharField(
        _('username'),
        max_length=150,
        unique=True,
        help_text=_('Auto-generated username for the user.'),
        error_messages={
            'unique': _("A user with that username already exists."),
        }
    )
    
    # Email verification fields
    email_verified = models.BooleanField(
        _('email verified'),
        default=False,
        help_text=_('Designates whether this user has verified their email address.')
    )
    
    email_verification_token = models.CharField(
        max_length=200,
        blank=True,
        help_text=_('Token for verifying email address')
    )
    
    email_verification_sent_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text=_('When the verification email was last sent')
    )
    
    # Password reset fields
    password_reset_token = models.CharField(
        max_length=200,
        blank=True,
        help_text=_('Token for password reset')
    )
    
    password_reset_sent_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text=_('When the password reset email was sent')
    )
    
    # Security fields
    last_login_ip = models.GenericIPAddressField(
        null=True,
        blank=True,
        help_text=_('IP address of last login')
    )
    
    login_attempts = models.PositiveIntegerField(
        default=0,
        help_text=_('Number of failed login attempts')
    )
    
    locked_until = models.DateTimeField(
        null=True,
        blank=True,
        help_text=_('Account locked until this time')
    )
    
    # Profile fields
    avatar = models.ImageField(
        upload_to='avatars/',
        null=True,
        blank=True,
        help_text=_('User profile picture')
    )

    objects = UserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')
        indexes = [
            models.Index(fields=['email']),
            models.Index(fields=['username']),
            models.Index(fields=['email_verified']),
        ]

    def __str__(self):
        return self.email

    def clean(self):
        super().clean()
        self.email = self.__class__.objects.normalize_email(self.email)

    def email_user(self, subject, message, from_email=None, **kwargs):
        """Send an email to this user."""
        from django.core.mail import send_mail
        send_mail(subject, message, from_email, [self.email], **kwargs)

    def generate_token(self, purpose: str) -> str:
        """Generate a secure token for email verification or password reset."""
        token = secrets.token_urlsafe(32)
        
        if purpose == 'email_verification':
            self.email_verification_token = token
            self.email_verification_sent_at = timezone.now()
        elif purpose == 'password_reset':
            self.password_reset_token = token
            self.password_reset_sent_at = timezone.now()
        
        self.save(update_fields=[
            f'{purpose}_token',
            f'{purpose}_sent_at'
        ])
        return token

    def verify_token(self, token: str, purpose: str, max_age_hours: int = 24) -> bool:
        """Verify a token for email verification or password reset."""
        if purpose == 'email_verification':
            stored_token = self.email_verification_token
            sent_at = self.email_verification_sent_at
        elif purpose == 'password_reset':
            stored_token = self.password_reset_token
            sent_at = self.password_reset_sent_at
        else:
            return False

        if not stored_token or not sent_at:
            return False

        # Check token age
        age = timezone.now() - sent_at
        if age.total_seconds() > max_age_hours * 3600:
            return False

        # Use constant-time comparison
        return secrets.compare_digest(stored_token, token)

    def clear_token(self, purpose: str) -> None:
        """Clear a verification or reset token."""
        if purpose == 'email_verification':
            self.email_verification_token = ''
            self.email_verification_sent_at = None
        elif purpose == 'password_reset':
            self.password_reset_token = ''
            self.password_reset_sent_at = None
        
        self.save(update_fields=[
            f'{purpose}_token',
            f'{purpose}_sent_at'
        ])

    def record_login_attempt(self, successful: bool, ip_address: str = None):
        """Record a login attempt and handle account locking."""
        if successful:
            self.login_attempts = 0
            self.locked_until = None
            if ip_address:
                self.last_login_ip = ip_address
        else:
            self.login_attempts += 1
            
            # Lock account after 5 failed attempts
            if self.login_attempts >= 5:
                self.locked_until = timezone.now() + timezone.timedelta(minutes=30)
        
        self.save(update_fields=['login_attempts', 'locked_until', 'last_login_ip'])

    def is_locked(self) -> bool:
        """Check if the account is currently locked."""
        if self.locked_until and self.locked_until > timezone.now():
            return True
        
        # Reset if lock has expired
        if self.locked_until:
            self.locked_until = None
            self.login_attempts = 0
            self.save(update_fields=['locked_until', 'login_attempts'])
        
        return False

==========

##########
FILE: backend/appauth/register.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/register.py
##########

from .models import *
from rest_framework import generics
from rest_framework import status
from .welcome import createWelcomeEmail
from .serializers import *
from rest_framework import generics
from knox.models import AuthToken
from rest_framework.response import Response
from rest_framework import generics, status
from django.conf import settings
from django.core.mail import send_mail
User = AppUser

# from api.getEnv import api_key, api_secret


class RegisterAPI(generics.GenericAPIView):
    serializer_class = RegisterSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        try:
            user = User.objects.create_user(
                username=serializer.validated_data.get('username'),
                password=serializer.validated_data.get('password'),
                email=serializer.validated_data.get('email'),
                first_name=serializer.validated_data.get('first_name'),
                last_name=serializer.validated_data.get('last_name'),
                phone=serializer.validated_data.get('phone'),
                avatar=serializer.validated_data.get('avatar'))
            user.save()
        except Exception as e:
            raise e

        token = AuthToken.objects.create(user)
        body = createWelcomeEmail(user.username)
        email_from = settings.EMAIL_HOST_USER
        recipient_list = [user.email]
        try:
            send_mail("Welcome to DissolveAI", f'''Welcome {user.username} to DissolveAI''',
                      email_from, recipient_list, html_message=body)
        except Exception as e:
            print("Error sending the email")

        return Response({
            "user": AppUserSerializer(user, context=self.get_serializer_context()).data,
            "token": token[1],
            "message": "User created successfully",
        }, status=status.HTTP_201_CREATED
        )


==========

##########
FILE: backend/appauth/otp.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/otp.py
##########


from rest_framework.decorators import api_view
from django.contrib.auth.models import User
import json
import datetime
from .serializers import *
from rest_framework.permissions import AllowAny
from rest_framework.decorators import permission_classes
from rest_framework.permissions import IsAuthenticated
from knox.models import AuthToken
from rest_framework import status
from rest_framework.response import Response
import pyotp

UserSerializer = AppUserSerializer

from .models import *


def send_sms():
    pass


def sendOtp(user, userData):
    secret = pyotp.random_base32()
    totp = pyotp.TOTP(secret).now()

    try:
        user_otp = UserOTP.objects.create(
            user=user,
            otp=totp
        )
        user_otp.save()
        saved_otp = True

        try:
            resp = send_sms(
                mobile=userData.phone.as_e164,
                message=f"Your Jobzy OTP is {user_otp.otp}. It expires in 5 minutes."
            )
            print(resp)
        except Exception as e:
            print(
                f"Error sending the otp: {e.__str__()}"
            )

    except Exception as e:
        print(
            f"Error saving the user otp: {e.__str__()}"
        )


def verifyOtp(userID, otp):
    try:
        user = User.objects.get(id=userID)
        user_otp = UserOTP.objects.get(user=user)
        if user_otp.otp == otp:
            return True
        else:
            return False
    except Exception as e:
        print(
            f"Error verifying the otp: {e.__str__()}"
        )
        return False


@api_view(['POST'])
def RequestOTPForLoginWithPhoneNumber(request):

    data = request.data
    print(data["phone"])
    try:
        user = AppUser.objects.get(
            phone=data["phone"]
        )

    except:
        return Response({"detail": "Sorry we couldnt find a user with such an phone number"}, status=status.HTTP_404_NOT_FOUND)
    secret = pyotp.random_base32()
    totp = pyotp.TOTP(secret).now()
    try:
        ds = UserOTP.objects.get(user=user)
        timedelta = datetime.datetime.now()-ds.updated_at.replace(tzinfo=None)
        if timedelta.seconds < 180:
            print(f"seconds {timedelta.seconds}")
            return Response({"detail": "Too many requests: Please wait for 180 seconds  before requesting another otp"}, status=status.HTTP_429_TOO_MANY_REQUESTS)
        else:
            ds.otp = totp
            ds.save()
    except Exception as e:
        print(
            f"Error saving the user otp: {e.__str__()}"
        )
        ds = UserOTP.objects.create(user=user, otp=totp)
        ds.save()

    try:
        resp = send_sms(
            mobile=data["phone"],
            message=f"Your Jobzy OTP is {ds.otp}. It expires in 5 minutes."
        )
        resp = json.loads(resp)
        print(resp)
        if resp[0]['status_code'] == '1000':
            return Response({
                "detail": "OTP sent successfully",
            }, status=status.HTTP_202_ACCEPTED)
        else:
            print(resp)
            return Response({"detail": "Trouble sending the sms"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    except Exception as e:
        print(
            f"Error sending the otp: {e.__str__()}"
        )
        return Response({"detail": "Trouble sending the sms"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def LoginWithOTP(request):

    data = request.data
    phone = data["phone"]
    otp = data["otp"]

    try:
        user = AppUser.objects.get(
            phone=phone
        )

    except:
        print(
            f"Error finding the user: {e.__str__()}"
        )
        return Response({"detail": "Sorry we couldnt find a user with such an phone number"}, status=status.HTTP_404_NOT_FOUND)

    try:
        saved_otp = UserOTP.objects.get(user=user)

        timedelta = datetime.datetime.now()-saved_otp.updated_at.replace(tzinfo=None)
        if timedelta.seconds > 300:
            print(f"seconds {timedelta.seconds}")
            saved_otp.delete()
            return Response({"detail": "OTP expired"}, status=status.HTTP_400_BAD_REQUEST)

        if saved_otp.otp == otp:
            token = AuthToken.objects.create(user)
            saved_otp.delete()
            return Response({
                "user": UserSerializer(user).data,
                "token": token[1],
            })
        else:
            return Response({"detail": "OTP is incorrect"}, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        print(
            f"Error verifying the otp: {e.__str__()}"
        )
        return Response({"detail": "Trouble authenticating the user"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


def CreatePasswordResetOtpEmail():
    pass


def OtpMessage():
    pass


@api_view(['POST'])
def request_reset_password(request):
    """reset_password with email, OTP and new password"""
    data = request.data
    print(data["email"])
    try:
        user = User.objects.get(email=data['email'])
    except:
        return Response({"detail": "Sorry we couldnt find a user with such an email"}, status=status.HTTP_404_NOT_FOUND)
    secret = pyotp.random_base32()
    totp = pyotp.TOTP(secret).now()
    try:
        ds = UserOTP.objects.get(user=user)
    except Exception as e:
        ds = UserOTP.objects.create(user=user, otp=totp)
    timedelta = datetime.now()-ds.timestamp.replace(tzinfo=None)
    if timedelta.seconds < 120:
        print(timedelta.seconds)
        return Response({"detail": "Please wait for 120 seconds before requesting another otp"}, status=status.HTTP_429_TOO_MANY_REQUESTS)
    ds.otp = totp
    ds.save()

    html_email = CreatePasswordResetOtpEmail(totp, user.username)
    # plain_text_email = OtpMessage(user.username, totp, False)
    # email_from = settings.EMAIL_HOST_USER
    # recipient_list = [data['email']]
    try:
        # send_mail("Password reset OTP", plain_text_email,
        #           email_from, recipient_list, html_message=html_email)
        return Response("sent a Password reset Email to the email you entered", status=status.HTTP_202_ACCEPTED)
    except Exception as e:
        return Response({"detail": "Trouble sending the email"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def verify_otp(request):
    """reset_password with email, OTP and new password"""
    data = request.data
    if data['email'] != '':
        try:
            user = User.objects.get(email=data['email'])
            saved_otp = UserOTP.objects.get(user=user).otp
            if user.is_active:
                # Check if otp is valid
                if data['otp'] == saved_otp:
                    return Response({"detail": "Otp has been verified"}, status=status.HTTP_202_ACCEPTED)
        except Exception as e:
            return Response({"detail": "Sorry we couldnt find a user with such an email"}, status=status.HTTP_404_NOT_FOUND)
    else:
        return Response({"detail": "email field is needed"},
                        status=status.HTTP_206_PARTIAL_CONTENT)


@api_view(['POST'])
def reset_password(request):
    """reset_password with email, OTP and new password"""
    data = request.data
    if data['email'] != '':
        try:
            user = User.objects.get(email=data['email'])
        except Exception as e:
            return Response({"detail": "Could not find such an email address", "error": e.__str__()}, status=status.HTTP_400_BAD_REQUEST)
        email_otp = data['otp']
        new_password = data['new_password']
        saved_otp = UserOTP.objects.get(user=user).otp
        saved_otp_object = UserOTP.objects.get(user=user)
        if user.is_active:
            # Check if otp is valid
            if data['otp'] == saved_otp:
                if new_password != '':
                    # Change Password
                    user.set_password(data['new_password'])
                    user.save()
                    saved_otp_object.delete()
                    # Here user otp will also be changed on save automatically
                    # email_from = settings.EMAIL_HOST_USER
                    recipient_list = [user.email]
                    try:
                        # send_mail("Successfully reset your password", f"Hi {user.username}, You Successfully reset your password",
                        #           email_from, recipient_list, html_message=SuccessfulPasswordResetHtmlEmail(user.username))
                        pass
                    except Exception as e:
                        print(e)
                    return Response({"detail": 'Successfully changed your password '}, status=status.HTTP_201_CREATED)
                else:
                    message = {
                        'detail': 'Password cant be empty'}
                    return Response(message, status=status.HTTP_400_BAD_REQUEST)
            else:
                message = {
                    'detail': 'OTP did not match'}
                return Response(message, status=status.HTTP_400_BAD_REQUEST)
        else:
            message = {
                'detail': 'Something went wrong'}
            return Response(message, status=status.HTTP_400_BAD_REQUEST)


==========

##########
FILE: backend/appauth/services/rate_limit_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/services/rate_limit_service.py
##########

import time
import logging
from typing import Optional, Dict, Any, List
from django.utils.translation import gettext as _
from django.core.cache import cache
from django.conf import settings
from dataclasses import dataclass
from collections import defaultdict
import threading

logger = logging.getLogger(__name__)


class RateLimitError(Exception):
    """Exception raised when rate limit is exceeded."""
    def __init__(self, message: str, retry_after: Optional[int] = None):
        self.message = message
        self.retry_after = retry_after
        super().__init__(message)

    
@dataclass
class RateLimitConfig:
    """Configuration for rate limiting."""
    max_attempts: int
    period: int  # in seconds
    block_duration: Optional[int] = None  # in seconds

class RateLimitExceeded(Exception):
    """Exception raised when rate limit is exceeded."""
    pass

class RateLimitService:
    """Service for handling rate limiting."""

    # Default configurations for different actions
    DEFAULT_CONFIGS = {
        'login': RateLimitConfig(
            max_attempts=5,
            period=300,  # 5 minutes
            block_duration=1800  # 30 minutes
        ),
        'registration': RateLimitConfig(
            max_attempts=5,
            period=3600,  # 1 hour
            block_duration=86400  # 24 hours
        ),
        'password_reset': RateLimitConfig(
            max_attempts=3,
            period=3600,  # 1 hour
            block_duration=7200  # 2 hours
        ),
        'verification_email': RateLimitConfig(
            max_attempts=3,
            period=3600,  # 1 hour
            block_duration=7200  # 2 hours
        ),
        'api': RateLimitConfig(
            max_attempts=100,
            period=60,  # 1 minute
            block_duration=300  # 5 minutes
        ),
        'social_auth': RateLimitConfig(
        max_attempts=10,
        period=300,  # 5 minutes
        block_duration=300  # 30 minutes
    ),
    }

    def __init__(self):
        """Initialize the rate limit service."""
        self._local = threading.local()
        self._local.memory_store = defaultdict(list)
        self.use_cache = hasattr(settings, 'CACHES') and settings.CACHES.get('default')

    def _get_cache_key(self, identifier: str, action: str) -> str:
        """
        Generate a cache key for rate limiting.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action being rate limited
            
        Returns:
            str: Cache key
        """
        return f"ratelimit:{action}:{identifier}"

    def _get_block_key(self, identifier: str, action: str) -> str:
        """
        Generate a cache key for blocking.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action being rate limited
            
        Returns:
            str: Block key
        """
        return f"ratelimit:block:{action}:{identifier}"

    def _clean_old_attempts(
        self,
        attempts: list,
        period: int,
        current_time: Optional[float] = None
    ) -> list:
        """
        Remove attempts older than the period.
        
        Args:
            attempts: List of timestamp attempts
            period: Time period in seconds
            current_time: Optional current time for testing
            
        Returns:
            list: Cleaned list of attempts
        """
        if not current_time:
            current_time = time.time()
            
        cutoff = current_time - period
        return [ts for ts in attempts if ts > cutoff]

    def record_attempt(
        self,
        identifier: str,
        action: str,
        timestamp: Optional[float] = None
    ) -> None:
        """
        Record a rate limit attempt.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action being rate limited
            timestamp: Optional timestamp for testing
            
        Raises:
            ValueError: If action is not recognized
        """
        if action not in self.DEFAULT_CONFIGS:
            raise ValueError(f"Unknown rate limit action: {action}")

        if not timestamp:
            timestamp = time.time()

        cache_key = self._get_cache_key(identifier, action)

        if self.use_cache:
            # Using Redis/Memcached
            attempts = cache.get(cache_key, [])
            attempts.append(timestamp)
            
            # Get config
            config = self.DEFAULT_CONFIGS[action]
            
            # Clean old attempts
            attempts = self._clean_old_attempts(attempts, config.period, timestamp)
            
            # Store updated attempts
            cache.set(
                cache_key,
                attempts,
                timeout=config.period
            )
        else:
            # Using memory store
            self._local.memory_store[cache_key].append(timestamp)

    def is_rate_limited(
    self,
    identifier: str,
    action: str,
    max_attempts: Optional[int] = None,
    period: Optional[int] = None
) -> bool:
        """Check if an action is rate limited."""
        if action not in self.DEFAULT_CONFIGS:
            raise ValueError(f"Unknown rate limit action: {action}")

        # Check if explicitly blocked
        block_key = self._get_block_key(identifier, action)
        if self.use_cache and cache.get(block_key):
            raise RateLimitError(
                _("Account temporarily blocked. Please try again later."),
                retry_after=self.DEFAULT_CONFIGS[action].block_duration
            )

        # Get configuration
        config = self.DEFAULT_CONFIGS[action]
        max_attempts = max_attempts or config.max_attempts
        period = period or config.period

        cache_key = self._get_cache_key(identifier, action)
        current_time = time.time()

        if self.use_cache:
            attempts = cache.get(cache_key, [])
        else:
            attempts = self._local.memory_store[cache_key]

        # Clean old attempts
        attempts = self._clean_old_attempts(attempts, period, current_time)

        # Check if rate limited
        if len(attempts) >= max_attempts:
            # Set blocking key if configured
            if config.block_duration and self.use_cache:
                cache.set(
                    block_key,
                    True,
                    timeout=config.block_duration
                )
                
            retry_after = int(min(
                config.block_duration or period,
                attempts[0] + period - current_time
            ))
            
            raise RateLimitError(
                _("Too many attempts. Please try again later."),
                retry_after=retry_after
            )

        return False

    def get_remaining_attempts(
        self,
        identifier: str,
        action: str
    ) -> Dict[str, Any]:
        """
        Get remaining attempts information.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action being checked
            
        Returns:
            Dict containing:
                remaining_attempts: Number of attempts remaining
                reset_time: Time until rate limit resets
                is_blocked: Whether explicitly blocked
        """
        if action not in self.DEFAULT_CONFIGS:
            raise ValueError(f"Unknown rate limit action: {action}")

        config = self.DEFAULT_CONFIGS[action]
        cache_key = self._get_cache_key(identifier, action)
        block_key = self._get_block_key(identifier, action)
        current_time = time.time()

        # Check if blocked
        is_blocked = False
        if self.use_cache:
            is_blocked = bool(cache.get(block_key))

        # Get attempts
        if self.use_cache:
            attempts = cache.get(cache_key, [])
        else:
            attempts = self._local.memory_store[cache_key]

        # Clean old attempts
        attempts = self._clean_old_attempts(attempts, config.period, current_time)

        # Calculate remaining attempts
        remaining = max(0, config.max_attempts - len(attempts))

        # Calculate reset time
        reset_time = 0
        if attempts:
            oldest_attempt = min(attempts)
            reset_time = max(0, oldest_attempt + config.period - current_time)

        return {
            'remaining_attempts': remaining,
            'reset_time': int(reset_time),
            'is_blocked': is_blocked
        }

    def reset_rate_limit(self, identifier: str, action: str) -> None:
        """
        Reset rate limit for an identifier.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action to reset
            
        Raises:
            ValueError: If action is not recognized
        """
        if action not in self.DEFAULT_CONFIGS:
            raise ValueError(f"Unknown rate limit action: {action}")

        cache_key = self._get_cache_key(identifier, action)
        block_key = self._get_block_key(identifier, action)

        if self.use_cache:
            cache.delete(cache_key)
            cache.delete(block_key)
        else:
            self._local.memory_store[cache_key] = []

        logger.info(
            f"Rate limit reset for {identifier} ({action})",
            extra={
                'identifier': identifier,
                'action': action
            }
        )

    def block_identifier(
        self,
        identifier: str,
        action: str,
        duration: Optional[int] = None
    ) -> None:
        """
        Explicitly block an identifier.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action to block
            duration: Optional block duration in seconds
            
        Raises:
            ValueError: If action is not recognized
        """
        if action not in self.DEFAULT_CONFIGS:
            raise ValueError(f"Unknown rate limit action: {action}")

        if not duration:
            duration = self.DEFAULT_CONFIGS[action].block_duration or 3600

        block_key = self._get_block_key(identifier, action)
        
        if self.use_cache:
            cache.set(block_key, True, timeout=duration)

        logger.info(
            f"Identifier blocked: {identifier} ({action})",
            extra={
                'identifier': identifier,
                'action': action,
                'duration': duration
            }
        )

    def unblock_identifier(self, identifier: str, action: str) -> None:
        """
        Remove explicit block from an identifier.
        
        Args:
            identifier: Usually an IP address or user ID
            action: Type of action to unblock
            
        Raises:
            ValueError: If action is not recognized
        """
        if action not in self.DEFAULT_CONFIGS:
            raise ValueError(f"Unknown rate limit action: {action}")

        block_key = self._get_block_key(identifier, action)
        
        if self.use_cache:
            cache.delete(block_key)

        logger.info(
            f"Identifier unblocked: {identifier} ({action})",
            extra={
                'identifier': identifier,
                'action': action
            }
        )

==========

##########
FILE: backend/appauth/services/email_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/services/email_service.py
##########

import logging
from typing import Optional, Dict, Any, List
from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.conf import settings
from django.core.mail import get_connection
from django.core.mail.backends.smtp import EmailBackend
from django.utils.translation import gettext as _

logger = logging.getLogger(__name__)

class EmailError(Exception):
    """Base exception for email-related errors."""
    pass

class EmailService:
    """Service for handling all email operations."""

    def __init__(self):
        self.from_email = getattr(
            settings,
            'DEFAULT_FROM_EMAIL',
            'noreply@yourdomain.com'
        )
        
        # Get email backend settings
        self.host = settings.EMAIL_HOST
        self.port = settings.EMAIL_PORT
        self.username = settings.EMAIL_HOST_USER
        self.password = settings.EMAIL_HOST_PASSWORD
        self.use_tls = settings.EMAIL_USE_TLS
        self.use_ssl = getattr(settings, 'EMAIL_USE_SSL', False)
        self.timeout = getattr(settings, 'EMAIL_TIMEOUT', None)
        
    def get_connection(self) -> EmailBackend:
        """Get a connection to the email server."""
        try:
            return get_connection(
                host=self.host,
                port=self.port,
                username=self.username,
                password=self.password,
                use_tls=self.use_tls,
                use_ssl=self.use_ssl,
                timeout=self.timeout
            )
        except Exception as e:
            logger.error(f"Failed to get email connection: {str(e)}")
            raise EmailError(_("Could not connect to email server"))

    def send_email(
        self,
        to_email: str,
        subject: str,
        template_name: str,
        context: Dict[str, Any],
        from_email: Optional[str] = None,
        bcc: Optional[List[str]] = None,
        attachments: Optional[List[Dict[str, Any]]] = None,
        priority: Optional[int] = None
    ) -> bool:
        """
        Send an email using a template.
        
        Args:
            to_email: Recipient email address
            subject: Email subject
            template_name: Name of the template (without .html/.txt extension)
            context: Context data for the template
            from_email: Optional sender email (defaults to DEFAULT_FROM_EMAIL)
            bcc: Optional list of BCC recipients
            attachments: Optional list of attachment dicts with 'filename' and 'content'
            priority: Optional email priority (1-5, 1 being highest)
            
        Returns:
            bool: True if email was sent successfully
            
        Raises:
            EmailError: If email sending fails
        """
        try:
            # Render templates
            html_content = render_to_string(f"{template_name}.html", context)
            text_content = strip_tags(html_content)  # Fallback for non-HTML clients
            
            # Create email message
            email = EmailMultiAlternatives(
                subject=subject,
                body=text_content,
                from_email=from_email or self.from_email,
                to=[to_email],
                bcc=bcc,
                connection=self.get_connection()
            )
            
            # Add HTML content
            email.attach_alternative(html_content, "text/html")
            
            # Add any attachments
            if attachments:
                for attachment in attachments:
                    email.attach(
                        attachment['filename'],
                        attachment['content'],
                        attachment.get('mimetype', 'application/octet-stream')
                    )
            
            # Set priority if specified
            if priority:
                if 1 <= priority <= 5:
                    email.extra_headers['Priority'] = str(priority)
                    
            # Send email
            email.send(fail_silently=False)
            
            logger.info(
                f"Email sent successfully to {to_email}",
                extra={
                    'template': template_name,
                    'to_email': to_email,
                    'subject': subject
                }
            )
            
            return True
            
        except Exception as e:
            logger.error(
                f"Failed to send email to {to_email}: {str(e)}",
                extra={
                    'template': template_name,
                    'to_email': to_email,
                    'subject': subject,
                    'error': str(e)
                },
                exc_info=True
            )
            raise EmailError(_("Failed to send email"))

    def send_verification_email(self, user) -> bool:
        """
        Send email verification email to user.
        
        Args:
            user: AppUser instance
            
        Returns:
            bool: True if email sent successfully
            
        Raises:
            EmailError: If email sending fails
        """
        # Generate verification token
        token = user.generate_token('email_verification')
        
        # Construct verification URL
        verification_url = f"{settings.FRONTEND_URL}/auth/verify-email?token={token}&email={user.email}"
        
        context = {
            'user': user,
            'verification_url': verification_url,
            'site_name': settings.SITE_NAME,
            'support_email': settings.SUPPORT_EMAIL,
            'token_expiry_hours': 24  # Token validity duration
        }
        
        return self.send_email(
            to_email=user.email,
            subject=_("Verify your email address"),
            template_name='auth/email/verification',
            context=context,
            priority=2  # High priority for verification emails
        )

    def send_password_reset_email(self, user) -> bool:
        """
        Send password reset email to user.
        
        Args:
            user: AppUser instance
            
        Returns:
            bool: True if email sent successfully
            
        Raises:
            EmailError: If email sending fails
        """
        # Generate password reset token
        token = user.generate_token('password_reset')
        
        # Construct reset URL
        reset_url = f"{settings.FRONTEND_URL}/auth/reset?token={token}&email={user.email}"
        
        context = {
            'user': user,
            'reset_url': reset_url,
            'site_name': settings.SITE_NAME,
            'support_email': settings.SUPPORT_EMAIL,
            'token_expiry_hours': 24,  # Token validity duration
            'ip_address': user.last_login_ip  # For security notification
        }
        
        return self.send_email(
            to_email=user.email,
            subject=_("Reset your password"),
            template_name='auth/email/password_reset',
            context=context,
            priority=2  # High priority for password reset
        )

    def send_password_change_notification(self, user) -> bool:
        """
        Send notification when password is changed.
        
        Args:
            user: AppUser instance
            
        Returns:
            bool: True if email sent successfully
            
        Raises:
            EmailError: If email sending fails
        """
        context = {
            'user': user,
            'site_name': settings.SITE_NAME,
            'support_email': settings.SUPPORT_EMAIL,
            'ip_address': user.last_login_ip,
            'timestamp': user.password_reset_sent_at
        }
        
        return self.send_email(
            to_email=user.email,
            subject=_("Your password has been changed"),
            template_name='auth/email/password_changed',
            context=context,
            priority=2
        )

    def send_suspicious_login_notification(
        self, 
        user,
        ip_address: str,
        location: Optional[str] = None,
        device_info: Optional[str] = None
    ) -> bool:
        """
        Send notification about suspicious login attempt.
        
        Args:
            user: AppUser instance
            ip_address: IP address of the login attempt
            location: Optional location info derived from IP
            device_info: Optional device/browser info
            
        Returns:
            bool: True if email sent successfully
            
        Raises:
            EmailError: If email sending fails
        """
        context = {
            'user': user,
            'ip_address': ip_address,
            'location': location,
            'device_info': device_info,
            'timestamp': user.last_login_ip,
            'site_name': settings.SITE_NAME,
            'support_email': settings.SUPPORT_EMAIL
        }
        
        return self.send_email(
            to_email=user.email,
            subject=_("Suspicious login attempt detected"),
            template_name='auth/email/suspicious_login',
            context=context,
            priority=1  # Highest priority for security notifications
        )

==========

##########
FILE: backend/appauth/services/google_auth_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/services/google_auth_service.py
##########

import logging
from typing import Tuple, Optional, Dict, Any
from django.conf import settings
from social_core.backends.google import GoogleOAuth2
from social_django.utils import load_strategy, load_backend
from django.contrib.auth import get_user_model
from ..models import AppUser
from .email_service import EmailService

logger = logging.getLogger(__name__)

class GoogleAuthError(Exception):
    """Base exception for Google authentication errors."""
    pass

class GoogleAuthService:
    """Service for handling Google OAuth authentication."""

    def __init__(self):
        self.email_service = EmailService()
        self.User = get_user_model()

    def get_or_create_user(
        self,
        user_data: Dict[str, Any],
        ip_address: Optional[str] = None
    ) -> Tuple[AppUser, bool]:
        """Get existing user or create new one from Google data."""
        try:
            email = user_data.get('email')
            if not email:
                raise GoogleAuthError("Email not provided by Google")

            # Normalize email
            email = email.lower().strip()

            try:
                # Try to get existing user
                user = self.User.objects.get(email=email)
                created = False
                
                logger.info(
                    f"Existing user logged in via Google: {email}",
                    extra={'ip_address': ip_address}
                )
                
            except self.User.DoesNotExist:
                # Create new user without explicitly setting username
                # Let the model's create_user method handle username generation
                user = self.User.objects.create_user(
                    email=email,
                    first_name=user_data.get('given_name', ''),
                    last_name=user_data.get('family_name', ''),
                    password=None  # Password not needed for OAuth
                )
                
                # Set additional fields
                user.email_verified = True  # Google has verified the email
                if 'picture' in user_data:
                    user.avatar = user_data['picture']
                
                user.save()
                created = True
                
                logger.info(
                    f"New user created via Google: {email}",
                    extra={'ip_address': ip_address}
                )

            return user, created

        except Exception as e:
            logger.error(
                "Failed to process Google user data",
                extra={
                    'error': str(e),
                    'email': user_data.get('email'),
                    'ip_address': ip_address
                },
                exc_info=True
            )
            raise GoogleAuthError(
                "Failed to process Google authentication. Please try again."
            )


==========

##########
FILE: backend/appauth/services/auth_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/appauth/services/auth_service.py
##########

import logging
from typing import Optional, Dict, Any, Tuple
from django.contrib.auth import authenticate
from django.utils import timezone
from django.conf import settings
from django.core.exceptions import ValidationError
from django.utils.translation import gettext as _
from django.db import transaction
from rest_framework.exceptions import AuthenticationFailed

from ..models import AppUser
from .email_service import EmailService, EmailError
from .rate_limit_service import RateLimitService
from .google_auth_service import GoogleAuthService, GoogleAuthError

logger = logging.getLogger(__name__)

class AuthenticationError(Exception):
    """Base exception for authentication errors."""
    pass

class RegistrationError(AuthenticationError):
    """Exception for registration-related errors."""
    pass

class AuthService:
    """Service for handling authentication operations."""

    def __init__(self):
        """Initialize auth service with required dependencies."""
        self.email_service = EmailService()
        self.rate_limiter = RateLimitService()
        self.google_auth_service = GoogleAuthService()

    @transaction.atomic
    def register_user(
        self,
        email: str,
        password: str,
        ip_address: Optional[str] = None,
        **extra_fields
    ) -> AppUser:
        """
        Register a new user with email and password.
        
        Args:
            email: User's email address
            password: User's password
            ip_address: Optional IP address for rate limiting
            **extra_fields: Additional fields for user creation
            
        Returns:
            AppUser: Created user instance
            
        Raises:
            RegistrationError: If registration fails
            ValidationError: If data validation fails
        """
        try:
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'registration',
                max_attempts=5,
                period=3600  # 1 hour
            ):
                raise RegistrationError(
                    _("Too many registration attempts. Please try again later.")
                )

            # Validate email
            if not email or '@' not in email:
                raise ValidationError(_("Invalid email address"))

            # Validate password
            if not password or len(password) < 8:
                raise ValidationError(_("Password must be at least 8 characters long"))

            # Normalize email
            email = email.lower().strip()

            with transaction.atomic():
                # Create user
                user = AppUser.objects.create_user(
                    email=email,
                    password=password,
                    **extra_fields
                )

                # Send verification email
                try:
                    self.email_service.send_verification_email(user)
                except EmailError as e:
                    logger.error(
                        f"Failed to send verification email: {str(e)}",
                        extra={'user_id': str(user.id)},
                        exc_info=True
                    )
                    # Don't raise - user is still created but unverified

                # Record successful registration
                if ip_address:
                    self.rate_limiter.record_attempt(ip_address, 'registration')

                logger.info(
                    f"User registered successfully: {email}",
                    extra={
                        'user_id': str(user.id),
                        'ip_address': ip_address
                    }
                )

                return user

        except ValidationError:
            raise
        except Exception as e:
            logger.error(
                f"Registration failed for {email}: {str(e)}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise RegistrationError(_("Registration failed. Please try again."))

    def login_user(
    self,
    email: str,
    password: str,
    ip_address: Optional[str] = None,
    device_info: Optional[str] = None
) -> Tuple[AppUser, bool]:
        """Authenticate a user with email and password."""
        try:
            # Check rate limit first
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'login',
                max_attempts=5,
                period=300
            ):
                raise AuthenticationFailed(
                    _("Too many login attempts. Please try again later.")
                )

            # Normalize email
            email = email.lower().strip()

            try:
                user = AppUser.objects.get(email=email)
            except AppUser.DoesNotExist:
                if ip_address:
                    self.rate_limiter.record_attempt(ip_address, 'login')
                raise AuthenticationFailed(_("Invalid email or password"))

            # Check if account is locked
            if user.is_locked():
                raise AuthenticationFailed(
                    _("Account is temporarily locked. Please try again later.")
                )

            # Authenticate
            authenticated_user = authenticate(email=email, password=password)
            if not authenticated_user:
                # Record failed attempt
                user.record_login_attempt(False, ip_address)
                if ip_address:
                    self.rate_limiter.record_attempt(ip_address, 'login')
                raise AuthenticationFailed(_("Invalid email or password"))

            # Record successful login
            user.record_login_attempt(True, ip_address)

            # Return tuple of (user, requires_verification)
            return user, not user.email_verified

        except AuthenticationFailed:
            raise
        except Exception as e:
            logger.error(
                f"Login failed for {email}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise AuthenticationFailed(_("Authentication failed"))
    
    def _is_suspicious_login(
        self,
        user: AppUser,
        ip_address: Optional[str],
        device_info: Optional[str]
    ) -> bool:
        """
        Check if login attempt is suspicious.
        
        Args:
            user: AppUser instance
            ip_address: IP address of login attempt
            device_info: Device/browser information
            
        Returns:
            bool: True if login appears suspicious
        """
        if not ip_address:
            return False

        # Check if this is first login from this IP
        if user.last_login_ip and user.last_login_ip != ip_address:
            # If location drastically different, might be suspicious
            if not self._is_ip_in_same_region(user.last_login_ip, ip_address):
                return True

        # Check login time pattern
        current_time = timezone.now().hour
        if not self._is_normal_login_time(current_time):
            return True

        # Additional checks could be added:
        # - Multiple failed attempts before success
        # - Multiple logins from different locations in short time
        # - Unusual device/browser combination
        # - Known malicious IP addresses
        
        return False

    def _is_ip_in_same_region(self, ip1: str, ip2: str) -> bool:
        """
        Check if two IPs are from the same geographic region.
        This is a placeholder - in production, use a proper IP geolocation service.
        
        Args:
            ip1: First IP address
            ip2: Second IP address
            
        Returns:
            bool: True if IPs are in same region
        """
        # Implement IP geolocation logic here
        # For now, just check first two octets as example
        return ip1.split('.')[:2] == ip2.split('.')[:2]

    def _is_normal_login_time(self, hour: int) -> bool:
        """
        Check if login time is within normal hours.
        
        Args:
            hour: Hour of day (0-23)
            
        Returns:
            bool: True if login time is normal
        """
        # Consider 1am-5am suspicious
        return not (1 <= hour <= 5)

    def logout_user(
        self,
        user: AppUser,
        all_sessions: bool = False,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Log out a user.
        
        Args:
            user: AppUser instance
            all_sessions: Whether to log out all sessions
            ip_address: Optional IP address
            
        Returns:
            bool: True if logout successful
        """
        try:
            # Handle token invalidation if using token auth
            if all_sessions:
                # Delete all auth tokens for user
                from knox.models import AuthToken
                AuthToken.objects.filter(user=user).delete()
            
            logger.info(
                f"User logged out successfully{' (all sessions)' if all_sessions else ''}",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except Exception as e:
            logger.error(
                "Logout failed",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address,
                    'error': str(e)
                },
                exc_info=True
            )
            return False

    def resend_verification_email(
        self,
        email: str,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Resend verification email.
        
        Args:
            email: User's email
            ip_address: Optional IP address for rate limiting
            
        Returns:
            bool: True if email sent successfully
            
        Raises:
            ValidationError: If process fails
        """
        try:
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'verification_email',
                max_attempts=3,
                period=3600  # 1 hour
            ):
                raise ValidationError(
                    _("Too many verification email requests. Please try again later.")
                )

            email = email.lower().strip()
            user = AppUser.objects.get(email=email)
            
            if user.email_verified:
                raise ValidationError(_("Email is already verified"))

            # Send verification email
            self.email_service.send_verification_email(user)
            
            if ip_address:
                self.rate_limiter.record_attempt(ip_address, 'verification_email')

            logger.info(
                f"Verification email resent to {email}",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except AppUser.DoesNotExist:
            raise ValidationError(_("User not found"))
        except ValidationError:
            raise
        except Exception as e:
            logger.error(
                f"Failed to resend verification email: {str(e)}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise ValidationError(_("Failed to resend verification email"))

        except AuthenticationFailed:
            raise
        except Exception as e:
            logger.error(
                f"Login failed for {email}: {str(e)}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise AuthenticationFailed(_("Authentication failed"))

    def verify_email(self, email: str, token: str) -> bool:
        """
        Verify a user's email address.
        
        Args:
            email: User's email
            token: Verification token
            
        Returns:
            bool: True if verification successful
            
        Raises:
            ValidationError: If verification fails
        """
        try:
            email = email.lower().strip()
            user = AppUser.objects.get(email=email)
            
            if user.email_verified:
                return True

            if user.verify_token(token, 'email_verification'):
                user.email_verified = True
                user.clear_token('email_verification')
                user.save()
                
                logger.info(
                    f"Email verified successfully: {email}",
                    extra={'user_id': str(user.id)}
                )
                return True
            
            raise ValidationError(_("Invalid or expired verification token"))

        except AppUser.DoesNotExist:
            raise ValidationError(_("User not found"))
        except Exception as e:
            logger.error(
                f"Email verification failed for {email}: {str(e)}",
                exc_info=True
            )
            raise ValidationError(_("Email verification failed"))

    def initiate_password_reset(
        self,
        email: str,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Start password reset process.
        
        Args:
            email: User's email
            ip_address: Optional IP address for rate limiting
            
        Returns:
            bool: True if reset email sent successfully
            
        Raises:
            ValidationError: If process fails
        """
        try:
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'password_reset',
                max_attempts=3,
                period=3600  # 1 hour
            ):
                raise ValidationError(
                    _("Too many password reset attempts. Please try again later.")
                )

            email = email.lower().strip()
            user = AppUser.objects.get(email=email)
            
            # Send password reset email
            self.email_service.send_password_reset_email(user)
            
            if ip_address:
                self.rate_limiter.record_attempt(ip_address, 'password_reset')

            logger.info(
                f"Password reset initiated for {email}",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except AppUser.DoesNotExist:
            # Don't reveal user existence, but log the attempt
            logger.info(
                f"Password reset attempted for non-existent user: {email}",
                extra={'ip_address': ip_address}
            )
            return True
        except Exception as e:
            logger.error(
                f"Password reset initiation failed for {email}: {str(e)}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise ValidationError(_("Failed to initiate password reset"))

    def reset_password(
        self,
        email: str,
        token: str,
        new_password: str,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Complete password reset process.
        
        Args:
            email: User's email
            token: Reset token
            new_password: New password
            ip_address: Optional IP address
            
        Returns:
            bool: True if password reset successful
            
        Raises:
            ValidationError: If reset fails
        """
        try:
            email = email.lower().strip()
            user = AppUser.objects.get(email=email)

            if not user.verify_token(token, 'password_reset'):
                raise ValidationError(_("Invalid or expired reset token"))

            # Validate new password
            if len(new_password) < 8:
                raise ValidationError(_("Password must be at least 8 characters long"))

            # Update password
            user.set_password(new_password)
            user.clear_token('password_reset')
            user.save()

            # Send confirmation email
            try:
                self.email_service.send_password_change_notification(user)
            except EmailError:
                logger.warning(
                    "Failed to send password change notification",
                    extra={
                        'user_id': str(user.id),
                        'ip_address': ip_address
                    }
                )

            logger.info(
                f"Password reset successful for {email}",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except AppUser.DoesNotExist:
            raise ValidationError(_("Invalid reset request"))
        except ValidationError:
            raise
        except Exception as e:
            logger.error(
                f"Password reset failed for {email}: {str(e)}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise ValidationError(_("Failed to reset password"))

    def change_password(
        self,
        user: AppUser,
        current_password: str,
        new_password: str,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Change user's password.
        
        Args:
            user: AppUser instance
            current_password: Current password
            new_password: New password
            ip_address: Optional IP address
            
        Returns:
            bool: True if password changed successfully
            
        Raises:
            ValidationError: If password change fails
        """
        try:
            # Verify current password
            if not user.check_password(current_password):
                raise ValidationError(_("Current password is incorrect"))

            # Validate new password
            if len(new_password) < 8:
                raise ValidationError(_("Password must be at least 8 characters long"))

            if current_password == new_password:
                raise ValidationError(_("New password must be different from current password"))

            # Update password
            user.set_password(new_password)
            user.save()

            # Send notification
            try:
                self.email_service.send_password_change_notification(user)
            except EmailError:
                logger.warning(
                    "Failed to send password change notification",
                    extra={
                        'user_id': str(user.id),
                        'ip_address': ip_address
                    }
                )

            logger.info(
                "Password changed successfully",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except ValidationError:
            raise
        except Exception as e:
            logger.error(
                "Password change failed",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address,
                    'error': str(e)
                },
                exc_info=True
            )
            raise ValidationError(_("Failed to change password"))

    def authenticate_google(
        self,
        access_token: str,
        id_token: Optional[str] = None,
        device_info: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None
    ) -> Tuple[AppUser, bool]:
        """
        Authenticate or create user using Google OAuth.
        
        Args:
            access_token: Google OAuth access token
            id_token: Optional ID token from Google
            device_info: Optional device information
            ip_address: Optional IP address
            
        Returns:
            Tuple of (user, created) where created indicates new user
            
        Raises:
            AuthenticationError: If authentication fails
        """
        try:
            # Check rate limit for social auth attempts
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'social_auth',
                max_attempts=10,
                period=300  # 5 minutes
            ):
                raise AuthenticationError(
                    _("Too many authentication attempts. Please try again later.")
                )

            # Authenticate with Google
            user, created = self.google_auth_service.authenticate_google(
                access_token=access_token,
                ip_address=ip_address
            )

            # Record successful authentication
            if ip_address:
                user.record_login_attempt(True, ip_address)

            # Check for suspicious activity
            if self._is_suspicious_login(user, ip_address, device_info):
                try:
                    self.email_service.send_suspicious_login_notification(
                        user,
                        ip_address,
                        device_info=device_info
                    )
                except EmailError:
                    # Log but don't prevent login
                    logger.warning(
                        "Failed to send suspicious login notification",
                        extra={
                            'user_id': str(user.id),
                            'ip_address': ip_address
                        }
                    )

            logger.info(
                f"{'New' if created else 'Existing'} user authenticated via Google",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address,
                    'created': created
                }
            )

            return user, created

        except GoogleAuthError as e:
            if ip_address:
                self.rate_limiter.record_attempt(ip_address, 'social_auth')
            raise AuthenticationError(str(e))
        except Exception as e:
            logger.error(
                "Google authentication failed",
                extra={
                    'error': str(e),
                    'ip_address': ip_address
                },
                exc_info=True
            )
            raise AuthenticationError(
                _("Authentication failed. Please try again later.")
            )

    def _is_suspicious_login(
        self,
        user: AppUser,
        ip_address: Optional[str],
        device_info: Optional[str]
    ) -> bool:
        """
        Check if login attempt is suspicious.
        """
        if not ip_address:
            return False

        # Check if this is first login from this IP
        if user.last_login_ip and user.last_login_ip != ip_address:
            # If location drastically different, might be suspicious
            if not self._is_ip_in_same_region(user.last_login_ip, ip_address):
                return True

        # Check login time pattern
        current_time = timezone.now().hour
        if not self._is_normal_login_time(current_time):
            return True

        # Additional checks could be added:
        # - Multiple failed attempts before success
        # - Multiple logins from different locations in short time
        # - Unusual device/browser combination
        # - Known malicious IP addresses
        
        return False

    def _is_ip_in_same_region(self, ip1: str, ip2: str) -> bool:
        """
        Check if two IPs are from the same geographic region.
        This is a placeholder - in production, use a proper IP geolocation service.
        """
        # Implement IP geolocation logic here
        # For now, just check first two octets as example
        return ip1.split('.')[:2] == ip2.split('.')[:2]

    def _is_normal_login_time(self, hour: int) -> bool:
        """
        Check if login time is within normal hours.
        """
        # Consider 1am-5am suspicious
        return not (1 <= hour <= 5)

    def logout_user(
        self,
        user: AppUser,
        all_sessions: bool = False,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Log out a user.
        """
        try:
            # Handle token invalidation if using token auth
            if all_sessions:
                # Delete all auth tokens for user
                from knox.models import AuthToken
                AuthToken.objects.filter(user=user).delete()
            
            logger.info(
                f"User logged out successfully{' (all sessions)' if all_sessions else ''}",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except Exception as e:
            logger.error(
                "Logout failed",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address,
                    'error': str(e)
                },
                exc_info=True
            )
            return False

    def resend_verification_email(
        self,
        email: str,
        ip_address: Optional[str] = None
    ) -> bool:
        """
        Resend verification email.
        """
        try:
            # Check rate limit
            if ip_address and self.rate_limiter.is_rate_limited(
                ip_address,
                'verification_email',
                max_attempts=3,
                period=3600  # 1 hour
            ):
                raise ValidationError(
                    _("Too many verification email requests. Please try again later.")
                )

            email = email.lower().strip()
            user = AppUser.objects.get(email=email)
            
            if user.email_verified:
                raise ValidationError(_("Email is already verified"))

            # Send verification email
            self.email_service.send_verification_email(user)
            
            if ip_address:
                self.rate_limiter.record_attempt(ip_address, 'verification_email')

            logger.info(
                f"Verification email resent to {email}",
                extra={
                    'user_id': str(user.id),
                    'ip_address': ip_address
                }
            )
            
            return True

        except AppUser.DoesNotExist:
            raise ValidationError(_("User not found"))
        except ValidationError:
            raise
        except Exception as e:
            logger.error(
                f"Failed to resend verification email: {str(e)}",
                extra={'ip_address': ip_address},
                exc_info=True
            )
            raise ValidationError(_("Failed to resend verification email"))

==========

##########
FILE: backend/chat/__init__.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/__init__.py
##########



==========

##########
FILE: backend/chat/views.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/views.py
##########

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.http import StreamingHttpResponse
from rest_framework import generics, permissions
from .models import Chat, MessagePair, Message, SavedSystemPrompt, Project, ProjectKnowledge, MessageContent, UserMemory, MemoryTag
from .serializers import ChatSerializer, MessageSerializer,SystemPromptSerializer, ProjectSerializer, ProjectKnowledgeSerializer, UserMemorySerializer, UserMemoryListSerializer, MemoryTagSerializer
import os
import json
import boto3
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import viewsets
from rest_framework.decorators import action
from .utils.token_counter import count_tokens,get_token_usage_stats
from .services.chat_service import ChatService
from .utils.file_validators import validate_image_size, validate_document_size, validate_mime_type
from django.core.exceptions import ValidationError
from rest_framework.pagination import PageNumberPagination
from django.db.models import Q
from django.utils import timezone
from django.db import models
from .services.memory_service import MemoryExtractionService


# Initialize Bedrock client
bedrock_runtime = boto3.client(
    service_name="bedrock-runtime",
    region_name="us-west-2",
    aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
    aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
)   
CLAUDE_35_SONNET_V1_0 = "anthropic.claude-3-5-sonnet-20240620-v1:0"
CLAUDE_35_SONNET_V2 = "anthropic.claude-3-5-sonnet-20241022-v2:0"
CLAUDE_35_HAIKU_V1_0 = "anthropic.claude-3-5-haiku-20241022-v1:0"



@api_view(['POST'])
@permission_classes([IsAuthenticated])
def claude_chat_view(request):
    chat_service = ChatService()
    
    if not request.data.get('message') and not request.FILES:
        return Response(
            {'error': 'Either message or files must be provided'}, 
            status=400
        )

    try:
        chat_id = request.data.get('chat_id')
        message_text = request.data.get('message', '')
        project_id = request.data.get('project_id')
        files = request.FILES.getlist('files', [])
        
        # Create or get chat
        chat = chat_service.create_or_get_chat(request.user, chat_id, message_text, project_id)
        
        # Create message pair and user message
        message_pair = MessagePair.objects.create(chat=chat)
        user_message = chat_service.create_new_message(
            message_pair=message_pair,
            role="user",
            text=message_text,
            files=files
        )

        # Send initial message data including file contents
        def stream_response(response):
            # Send user message data
            user_message_data = {
                'type': 'message',
                'message': {
                    'id': str(user_message.id),
                    'role': 'user',
                    'contents': [{
                        'id': str(content.id),
                        'content_type': content.content_type,
                        'text_content': content.text_content,
                        'file_content': request.build_absolute_uri(content.file_content.url) if content.file_content else None,
                        'mime_type': content.mime_type,
                        'created_at': content.created_at.isoformat(),
                        'edited_at': content.edited_at.isoformat() if content.edited_at else None
                    } for content in user_message.contents.all()],
                    'created_at': user_message.created_at.isoformat(),
                    'message_pair': str(message_pair.id)
                }
            }
            yield json.dumps(user_message_data) + '\n'

            # Create initial assistant message with empty text content
            assistant_message = chat_service.create_new_message(
                message_pair=message_pair,
                role="assistant",
                text=""  # Initialize with empty text
            )
            
            # Create initial text content for assistant message
            assistant_content = MessageContent.objects.create(
                message=assistant_message,
                content_type='text',
                text_content=''
            )
            
            # Send initial assistant message data
            assistant_init_data = {
                'type': 'message',
                'message': {
                    'id': str(assistant_message.id),
                    'role': 'assistant',
                    'contents': [{
                        'id': str(assistant_content.id),
                        'content_type': 'text',
                        'text_content': '',
                        'created_at': assistant_content.created_at.isoformat()
                    }],
                    'created_at': assistant_message.created_at.isoformat(),
                    'message_pair': str(message_pair.id)
                }
            }
            yield json.dumps(assistant_init_data) + '\n'

            # Stream the assistant's response
            current_text = ""
            
            for chunk in response['body']:
                chunk_data = json.loads(chunk['chunk']['bytes'].decode())
                if chunk_data['type'] == 'content_block_delta':
                    content = chunk_data['delta']['text']
                    current_text += content
                    # Update the message content in the database
                    assistant_content.text_content = current_text
                    assistant_content.save()
                    
                    yield json.dumps({
                        'type': 'content',
                        'message_id': str(assistant_message.id),
                        'content': content
                    }) + '\n'

            # Send chat ID at the end
            yield json.dumps({
                'type': 'chat_id',
                'content': str(chat.id)
            }) + '\n'
            
            # Extract memories from this conversation asynchronously
            try:
                memory_service = MemoryExtractionService()
                # Extract memories from the current message pair
                extracted_memories = memory_service.extract_memories_from_chat(chat, message_pair)
                if extracted_memories:
                    print(f"Extracted {len(extracted_memories)} memories from chat {chat.id}")
            except Exception as e:
                print(f"Error extracting memories: {e}")

        # Prepare messages for Claude
        messages = chat_service.prepare_message_history(chat, message_text)
        body = chat_service.create_chat_request_body(messages, chat)
        response = chat_service.invoke_model(body)

        return StreamingHttpResponse(
            stream_response(response),
            content_type='text/event-stream'
        )

    except Exception as e:
        raise e

class ChatMessagesListView(generics.ListCreateAPIView):
    serializer_class = MessageSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        chat_id = self.kwargs['chat_id']
        message_pairs = MessagePair.objects.filter(chat_id=chat_id).order_by('created_at')
        messages = []
        for pair in message_pairs:
            messages.extend(pair.messages.all())
        return messages

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        chat = Chat.objects.get(id=self.kwargs['chat_id'])
        
        messages = []
        for message in serializer.data:
            message_contents = []
            for content in message['contents']:
                message_contents.append({
                    'id': content['id'],
                    'content_type': content['content_type'],
                    'text_content': content['text_content'],
                    'file_content': content['file_content'],
                    'mime_type': content['mime_type'],
                    'edited_at': content['edited_at'],
                    'created_at': content['created_at']
                })

            messages.append({
                'id': message['id'],
                'role': message['role'],
                'contents': message_contents,
                'created_at': message['created_at'],
                'message_pair': message['message_pair'],
                'hidden': message['hidden']
            })

        return Response({
            'system_prompt': chat.system_prompt,
            'messages': messages
        })

    def perform_create(self, serializer):
        chat_id = self.kwargs['chat_id']
        chat = Chat.objects.get(id=chat_id)
        message_pair = MessagePair.objects.create(chat=chat)
        serializer.save(message_pair=message_pair)

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def chat_list_view(request):
    if request.method == 'GET':
        chats = Chat.objects.filter(user=request.user).order_by('-created_at')
        return Response([{'id': chat.id, 'title': chat.title} for chat in chats])
    elif request.method == 'POST':
        title = request.data.get('title', 'New Chat')
        chat = Chat.objects.create(user=request.user, title=title)
        return Response({'id': chat.id, 'title': chat.title})
    
class ChatDetailView(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = ChatSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Chat.objects.filter(user=self.request.user)

    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        data = serializer.data
        data['system_prompt'] = instance.system_prompt
        return Response(data)

class ChatListView(generics.ListCreateAPIView):
    serializer_class = ChatSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Chat.objects.filter(user=self.request.user).order_by('-created_at')

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def chat_list_view(request):
    if request.method == 'GET':
        chats = Chat.objects.filter(user=request.user).order_by('-created_at')
        return Response([{'id': chat.id, 'title': chat.title} for chat in chats])
    elif request.method == 'POST':
        title = request.data.get('title', 'New Chat')
        chat = Chat.objects.create(user=request.user, title=title)
        return Response({'id': chat.id, 'title': chat.title})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def chat_messages_view(request, chat_id):
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

    message_pairs = MessagePair.objects.filter(chat=chat).order_by('created_at')
    messages = []
    for pair in message_pairs:
        for message in pair.messages.all():
            messages.append({
                'id': message.id,
                'role': message.role,
                'contents': [{
                    'id': content.id,
                    'content_type': content.content_type,
                    'text_content': content.text_content,
                    'file_content': content.file_content.url if content.file_content else None,
                    'mime_type': content.mime_type,
                    'edited_at': content.edited_at,
                    'created_at': content.created_at
                } for content in message.contents.all()],
                'created_at': message.created_at,
                'message_pair': message.message_pair.id,
                'hidden': message.hidden
            })
    return Response(messages)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def update_chat_system_prompt(request, chat_id):
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
        chat.system_prompt = request.data.get('system_prompt', '')
        chat.save()
        return Response({'status': 'success'})
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

class SavedSystemPromptListCreateView(generics.ListCreateAPIView):
    serializer_class = SystemPromptSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return SavedSystemPrompt.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class SavedSystemPromptRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):    
    serializer_class = SystemPromptSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return SavedSystemPrompt.objects.filter(user=self.request.user)

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def update_saved_system_prompt(request, prompt_id):
    try:
        prompt = SavedSystemPrompt.objects.get(id=prompt_id, user=request.user)
        prompt.title = request.data.get('title', prompt.title)
        prompt.prompt = request.data.get('prompt', prompt.prompt)
        prompt.save()
        return Response({'status': 'success'})
    except SavedSystemPrompt.DoesNotExist:
        return Response({'error': 'Saved system prompt not found'}, status=404)
    

class StandardResultsSetPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

class ChatViewSet(viewsets.ModelViewSet):
    serializer_class = ChatSerializer
    pagination_class = StandardResultsSetPagination
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = Chat.objects.filter(user=self.request.user)
        search = self.request.query_params.get('search', None)
        
        if search:
            queryset = queryset.filter(
                Q(title__icontains=search) |
                Q(message_pairs__messages__contents__text_content__icontains=search)
            ).distinct()
            
        return queryset.order_by('-created_at')

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    @action(detail=True, methods=['post'])
    def archive(self, request, pk=None):
        chat = self.get_object()
        chat.is_archived = True
        chat.save()
        return Response({'status': 'chat archived'})

    @action(detail=True, methods=['post'])
    def unarchive(self, request, pk=None):
        chat = self.get_object()
        chat.is_archived = False
        chat.save()
        return Response({'status': 'chat unarchived'})

class ProjectViewSet(viewsets.ModelViewSet):
    serializer_class = ProjectSerializer
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        queryset = Project.objects.filter(user=self.request.user)
        search = self.request.query_params.get('search', None)
        
        if search:
            queryset = queryset.filter(
                Q(name__icontains=search) |
                Q(description__icontains=search)
            )
            
        return queryset.order_by('-created_at')

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    @action(detail=True, methods=['get'])
    def knowledge(self, request, pk=None):
        project = self.get_object()
        knowledge_items = project.knowledge_items.all()
        serializer = ProjectKnowledgeSerializer(knowledge_items, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def chats(self, request, pk=None):
        project = self.get_object()
        chats = Chat.objects.filter(project=project).order_by('-created_at')
        serializer = ChatSerializer(chats, many=True)
        return Response(serializer.data)

class ProjectKnowledgeViewSet(viewsets.ModelViewSet):
    serializer_class = ProjectKnowledgeSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return ProjectKnowledge.objects.filter(project__user=self.request.user)

    def perform_create(self, serializer):
        from .utils.token_counter import count_tokens
        content = self.request.data.get('content', '')
        token_count = count_tokens(content)
        serializer.save(token_count=token_count)

    @action(detail=True, methods=['patch'])
    def toggle(self, request, pk=None):
        knowledge = self.get_object()
        knowledge.include_in_chat = not knowledge.include_in_chat
        knowledge.save()
        return Response({'include_in_chat': knowledge.include_in_chat})

# Modify the existing chat_view to include project knowledge
def get_project_knowledge(chat):
    if not chat.project:
        return ""
    
    knowledge_items = chat.project.knowledge_items.filter(include_in_chat=True)
    if not knowledge_items:
        return ""
        
    knowledge_text = "\n\n".join([
        f"### {item.title} ###\n{item.content}"
        for item in knowledge_items
    ])
    
    return f"\nProject Knowledge:\n{knowledge_text}\n"

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_chat_token_usage(request, chat_id):
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
        stats = get_token_usage_stats(chat)
        return Response(stats)
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_project_token_usage(request, project_id):
    try:
        project = Project.objects.get(id=project_id, user=request.user)
        total_tokens = project.total_knowledge_tokens
        return Response({
            'total_tokens': total_tokens,
            'max_tokens': 160000,
            'usage_percentage': (total_tokens / 160000) * 100
        })
    except Project.DoesNotExist:
        return Response({'error': 'Project not found'}, status=404)

class ProjectChatsView(generics.ListAPIView):
    serializer_class = ChatSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        project_id = self.kwargs.get('project_id')
        return Chat.objects.filter(
            user=self.request.user,
            project_id=project_id
        ).order_by('-created_at')

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def edit_message(request, message_id):
    try:
        message = Message.objects.get(id=message_id)
        
        # Store original text if this is the first edit
        if not message.original_text:
            message.original_text = message.text
            
        message.text = request.data.get('text', message.text)
        message.token_count = count_tokens(message.text)
        message.save()
        
        # If this is a user message, remove the associated assistant message
        if message.role == 'user':
            message_pair = message.message_pair
            message_pair.messages.filter(role='assistant').delete()
            
        return Response({'status': 'success'})
    except Message.DoesNotExist:
        return Response({'error': 'Message not found'}, status=404)

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def toggle_message_pair(request, pair_id):
    try:
        message_pair = MessagePair.objects.get(id=pair_id)
        messages = message_pair.messages.all()
        hidden = request.data.get('hidden', True)
        
        for message in messages:
            message.hidden = hidden
            message.save()
            
        return Response({'status': 'success'})
    except MessagePair.DoesNotExist:
        return Response({'error': 'Message pair not found'}, status=404)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_message_pair(request, pair_id):
    try:
        message_pair = MessagePair.objects.get(id=pair_id, chat__user=request.user)
        message_pair.delete()
        return Response({'message': 'Message pair deleted successfully'})
    except MessagePair.DoesNotExist:
        return Response({'error': 'Message pair not found'}, status=404)
    except Exception as e:
        return Response({'error': str(e)}, status=400)


# Memory Management Views

class MemoryPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100


class UserMemoryViewSet(viewsets.ModelViewSet):
    """ViewSet for managing user memories"""
    permission_classes = [IsAuthenticated]
    pagination_class = MemoryPagination
    
    def get_queryset(self):
        queryset = UserMemory.objects.filter(user=self.request.user)
        
        # Filter by category
        category = self.request.query_params.get('category')
        if category:
            queryset = queryset.filter(category=category)
        
        # Filter by tags
        tag_names = self.request.query_params.getlist('tags')
        if tag_names:
            queryset = queryset.filter(tags__name__in=tag_names).distinct()
        
        # Filter by active status
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        # Search in summary and raw content
        search = self.request.query_params.get('search')
        if search:
            queryset = queryset.filter(
                Q(summary__icontains=search) | Q(raw_content__icontains=search)
            )
        
        return queryset.order_by('-created_at')
    
    def get_serializer_class(self):
        if self.action == 'list':
            return UserMemoryListSerializer
        return UserMemorySerializer
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    @action(detail=True, methods=['post'])
    def verify(self, request, pk=None):
        """Mark a memory as verified by the user"""
        memory = self.get_object()
        memory.is_verified = True
        memory.save()
        return Response({'message': 'Memory verified successfully'})
    
    @action(detail=True, methods=['post'])
    def toggle_active(self, request, pk=None):
        """Toggle the active status of a memory"""
        memory = self.get_object()
        memory.is_active = not memory.is_active
        memory.save()
        status = 'activated' if memory.is_active else 'deactivated'
        return Response({'message': f'Memory {status} successfully'})


class MemoryTagViewSet(viewsets.ModelViewSet):
    """ViewSet for managing memory tags"""
    serializer_class = MemoryTagSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        # Return tags that are used by the current user's memories
        return MemoryTag.objects.filter(
            memories__user=self.request.user
        ).distinct().order_by('name')


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def extract_memories_from_chat(request, chat_id):
    """Manually trigger memory extraction for a specific chat"""
    try:
        chat = Chat.objects.get(id=chat_id, user=request.user)
        
        memory_service = MemoryExtractionService()
        memories = memory_service.extract_memories_from_chat(chat)
        
        serializer = UserMemoryListSerializer(memories, many=True)
        
        return Response({
            'message': f'Extracted {len(memories)} memories from chat',
            'memories': serializer.data
        })
        
    except Chat.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)
    except Exception as e:
        return Response({'error': str(e)}, status=500)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def memory_stats(request):
    """Get memory statistics for the user"""
    user = request.user
    
    total_memories = UserMemory.objects.filter(user=user).count()
    active_memories = UserMemory.objects.filter(user=user, is_active=True).count()
    verified_memories = UserMemory.objects.filter(user=user, is_verified=True).count()
    
    # Category breakdown
    category_stats = UserMemory.objects.filter(user=user, is_active=True).values('category').annotate(
        count=models.Count('id')
    ).order_by('-count')
    
    # Recent memories (last 7 days)
    from datetime import timedelta
    recent_cutoff = timezone.now() - timedelta(days=7)
    recent_memories = UserMemory.objects.filter(
        user=user, 
        created_at__gte=recent_cutoff
    ).count()
    
    return Response({
        'total_memories': total_memories,
        'active_memories': active_memories,
        'verified_memories': verified_memories,
        'recent_memories': recent_memories,
        'category_breakdown': list(category_stats),
        'verification_rate': round((verified_memories / total_memories * 100) if total_memories > 0 else 0, 1)
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_user_context(request):
    """Get relevant user memories for context in conversations"""
    user = request.user
    category = request.query_params.get('category')
    limit = int(request.query_params.get('limit', 10))
    
    memory_service = MemoryExtractionService()
    memories = memory_service.get_relevant_memories(user, category, limit)
    
    # Mark as referenced
    if memories:
        memory_service.mark_memories_as_referenced(memories)
    
    serializer = UserMemoryListSerializer(memories, many=True)
    return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def validate_file_view(request):
    file = request.FILES.get('file')
    if not file:
        return Response({'error': 'No file provided'}, status=400)
    
    try:
        mime_type = validate_mime_type(file)
        
        if mime_type.startswith('image/'):
            validate_image_size(file)
        else:
            validate_document_size(file)
            
        return Response({
            'valid': True,
            'mime_type': mime_type
        })
    except ValidationError as e:
        return Response({
            'valid': False,
            'error': str(e)
        }, status=400)

==========

##########
FILE: backend/chat/file_handlers.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/file_handlers.py
##########

import os
import zipfile
import shutil
from django.conf import settings
from django.core.files.storage import default_storage
from .models import Chat, Attachment

def handle_file_upload(file, chat_id):
    chat = Chat.objects.get(id=chat_id)
    file_name = default_storage.save(f'chat_{chat_id}/{file.name}', file)
    file_path = os.path.join(settings.MEDIA_ROOT, file_name)

    if file_name.endswith('.zip'):
        extract_path = os.path.join(settings.MEDIA_ROOT, f'chat_{chat_id}/extracted')
        with zipfile.ZipFile(file_path, 'r') as zip_ref:
            zip_ref.extractall(extract_path)
        
        for root, dirs, files in os.walk(extract_path):
            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, extract_path)
                Attachment.objects.create(
                    chat=chat,
                    file=f'chat_{chat_id}/extracted/{relative_path}',
                    original_name=file
                )
        
        os.remove(os.path.join(settings.MEDIA_ROOT, file_name))
    else:
        Attachment.objects.create(
            chat=chat,
            file=file_name,
            original_name=file.name
        )

    return True

def get_file_contents(file_path, max_chars=None):
    with open(file_path, 'r') as file:
        content = file.read(max_chars) if max_chars else file.read()
    return content

def delete_attachment(attachment_id):
    attachment = Attachment.objects.get(id=attachment_id)
    file_path = os.path.join(settings.MEDIA_ROOT, str(attachment.file))
    
    if os.path.exists(file_path):
        if os.path.isdir(file_path):
            shutil.rmtree(file_path)
        else:
            os.remove(file_path)
    
    attachment.delete()
    return True

==========

##########
FILE: backend/chat/serializers.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/serializers.py
##########

# serializers.py
from rest_framework import serializers
from .models import Chat, Message, MessagePair, SavedSystemPrompt, Project, ProjectKnowledge, MessageContent, UserMemory, MemoryTag

class MessageContentSerializer(serializers.ModelSerializer):
    class Meta:
        model = MessageContent
        fields = ['id', 'content_type', 'text_content', 'file_content', 'mime_type', 'edited_at', 'created_at']

class MessageSerializer(serializers.ModelSerializer):
    contents = MessageContentSerializer(many=True, read_only=True)
    
    class Meta:
        model = Message
        fields = ['id', 'message_pair', 'role', 'contents', 'hidden', 'created_at', 'is_archived', 'token_count']

class ChatSerializer(serializers.ModelSerializer):
    class Meta:
        model = Chat
        fields = ['id', 'title', 'created_at', 'system_prompt', 'project', 'user']

class SystemPromptSerializer(serializers.ModelSerializer):
    class Meta:
        model = SavedSystemPrompt
        fields = '__all__'
        read_only_fields = ['user']

class MessagePairSerializer(serializers.ModelSerializer):
    messages = MessageSerializer(many=True, read_only=True)

    class Meta:
        model = MessagePair
        fields = '__all__'

class ProjectSerializer(serializers.ModelSerializer):
    class Meta:
        model = Project
        fields = ['id', 'name', 'description', 'instructions', 'created_at', 'updated_at', 'total_knowledge_tokens']
        read_only_fields = ['created_at', 'updated_at']

class ProjectKnowledgeSerializer(serializers.ModelSerializer):
    token_count = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = ProjectKnowledge
        fields = ['id', 'project', 'content', 'title', 'include_in_chat', 
                 'token_count', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at', 'token_count']

    def validate(self, data):
        from .utils.token_counter import count_tokens
        
        content = data.get('content', '')
        project = data.get('project')
        
        # Count tokens for new content
        token_count = count_tokens(content)
        
        # Validate against project limits
        is_valid, error_message = project.validate_knowledge_tokens(token_count)
        if not is_valid:
            raise serializers.ValidationError(error_message)
            
        return data

class MemoryTagSerializer(serializers.ModelSerializer):
    memory_count = serializers.SerializerMethodField()
    
    class Meta:
        model = MemoryTag
        fields = ['id', 'name', 'color', 'created_at', 'memory_count']
        read_only_fields = ['created_at']
    
    def get_memory_count(self, obj):
        """Return the number of active memories with this tag"""
        return obj.memories.filter(is_active=True).count()

class UserMemorySerializer(serializers.ModelSerializer):
    tags = MemoryTagSerializer(many=True, read_only=True)
    tag_ids = serializers.ListField(
        child=serializers.IntegerField(),
        write_only=True,
        required=False,
        help_text="List of tag IDs to associate with this memory"
    )
    
    class Meta:
        model = UserMemory
        fields = [
            'id', 'summary', 'raw_content', 'confidence_score', 'category',
            'tags', 'tag_ids', 'is_verified', 'is_active', 'source_message_pair',
            'created_at', 'updated_at', 'last_referenced'
        ]
        read_only_fields = ['created_at', 'updated_at', 'last_referenced']
    
    def create(self, validated_data):
        tag_ids = validated_data.pop('tag_ids', [])
        memory = UserMemory.objects.create(**validated_data)
        
        if tag_ids:
            tags = MemoryTag.objects.filter(id__in=tag_ids)
            memory.tags.set(tags)
        
        return memory
    
    def update(self, instance, validated_data):
        tag_ids = validated_data.pop('tag_ids', None)
        
        # Update other fields
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        
        # Update tags if provided
        if tag_ids is not None:
            tags = MemoryTag.objects.filter(id__in=tag_ids)
            instance.tags.set(tags)
        
        return instance

class UserMemoryListSerializer(serializers.ModelSerializer):
    """Simplified serializer for memory lists"""
    tags = MemoryTagSerializer(many=True, read_only=True)
    tag_count = serializers.SerializerMethodField()
    
    class Meta:
        model = UserMemory
        fields = [
            'id', 'summary', 'category', 'confidence_score', 'is_verified', 
            'is_active', 'tags', 'tag_count', 'created_at', 'last_referenced'
        ]
    
    def get_tag_count(self, obj):
        return obj.tags.count()

==========

##########
FILE: backend/chat/tests.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/tests.py
##########

from django.test import TestCase

# Create your tests here.


==========

##########
FILE: backend/chat/urls.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/urls.py
##########

# chat/urls.py
from django.urls import path, include
from .views import (
    ChatViewSet, ProjectViewSet, ProjectKnowledgeViewSet,
    ChatListView, ChatMessagesListView, ChatDetailView, claude_chat_view,
    update_chat_system_prompt, SavedSystemPromptListCreateView,
    SavedSystemPromptRetrieveUpdateDestroyView,
    ProjectChatsView, get_chat_token_usage, edit_message, toggle_message_pair,
    delete_message_pair, validate_file_view, UserMemoryViewSet, MemoryTagViewSet,
    extract_memories_from_chat, memory_stats, get_user_context
)
from rest_framework.routers import DefaultRouter

# Set up the router
router = DefaultRouter()
router.register(r'chats', ChatViewSet, basename='chat')
router.register(r'projects', ProjectViewSet, basename='project')
router.register(r'knowledge', ProjectKnowledgeViewSet, basename='knowledge')
router.register(r'memories', UserMemoryViewSet, basename='memory')
router.register(r'memory-tags', MemoryTagViewSet, basename='memory-tag')

urlpatterns = [
    # Include router URLs first
    path('', include(router.urls)),
    
    # Chat related URLs
    path('chat/', claude_chat_view, name='chat'),
    path('chats/<str:pk>/', ChatDetailView.as_view(), name='chat-detail'),
    path('chats/<str:chat_id>/messages/', ChatMessagesListView.as_view(), name='chat-messages'),
    path('messages/<str:message_id>/edit/', edit_message, name='edit-message'),
    path('message-pairs/<str:pair_id>/toggle/', toggle_message_pair, name='toggle-message-pair'),
    path('message-pairs/<str:pair_id>/delete/', delete_message_pair, name='delete-message-pair'),
    
    # System prompts
    path('saved-system-prompts/', SavedSystemPromptListCreateView.as_view()),
    path('saved-system-prompts/<str:pk>/', SavedSystemPromptRetrieveUpdateDestroyView.as_view()),
    
    # Project chats
    path('projects/<str:pk>/chats/', ProjectChatsView.as_view(), name='project-chats'),
    
    # Token usage
    path('chats/<str:chat_id>/tokens/', get_chat_token_usage, name='chat-tokens'),
    
    # Memory related URLs
    path('chats/<str:chat_id>/extract-memories/', extract_memories_from_chat, name='extract-memories'),
    path('memory/stats/', memory_stats, name='memory-stats'),
    path('memory/context/', get_user_context, name='user-context'),

    # File validation
    path('validate-file/', validate_file_view, name='validate-file'),
]


==========

##########
FILE: backend/chat/apps.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/apps.py
##########

from django.apps import AppConfig


class ChatConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chat'


==========

##########
FILE: backend/chat/models.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/models.py
##########

from django.db import models
from django.core.exceptions import ValidationError
from .utils.file_validators import validate_image_size, validate_document_size, validate_mime_type
import uuid
import base64
from django.utils import timezone

class MessageContent(models.Model):
    CONTENT_TYPES = (
        ('text', 'Text'),
        ('image', 'Image'),
        ('document', 'Document')    
    )
    
    message = models.ForeignKey('Message', related_name='contents', on_delete=models.CASCADE)
    content_type = models.CharField(max_length=10, choices=CONTENT_TYPES)
    text_content = models.TextField(null=True, blank=True)
    file_content = models.FileField(
        upload_to='chat_contents/%Y/%m/%d/',
        null=True, blank=True,
        validators=[validate_mime_type]
    )
    edited_at = models.DateTimeField(auto_now=True, null=True)
    mime_type = models.CharField(max_length=100, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def clean(self):
        if self.content_type == 'text' and not self.text_content:
            raise ValidationError('Text content is required for text type')
        
        if self.content_type in ['image', 'document'] and not self.file_content:
            raise ValidationError('File content is required for image/document type')
        
        if self.content_type == 'image':
            validate_image_size(self.file_content)
        
        if self.content_type == 'document':
            validate_document_size(self.file_content)
        
        # Validate content limits per message
        content_count = MessageContent.objects.filter(
            message=self.message,
            content_type=self.content_type
        ).count()
        
        if self.content_type == 'image' and content_count >= 20:
            raise ValidationError('Maximum 20 images per message')
        
        if self.content_type == 'document' and content_count >= 5:
            raise ValidationError('Maximum 5 documents per message')

    def save(self, *args, **kwargs):
        if self.file_content:
            self.mime_type = validate_mime_type(self.file_content)
        super().save(*args, **kwargs)

class Message(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    message_pair = models.ForeignKey('MessagePair', on_delete=models.CASCADE, related_name='messages')
    role = models.CharField(max_length=10, choices=(("user", "user"), ("assistant", "assistant")))
    hidden = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    is_archived = models.BooleanField(default=False)
    token_count = models.IntegerField(default=0)

    def get_content(self) -> list:
        """
        Get message content in Claude API format
        Returns a list of content blocks
        """
        content_blocks = []
        
        for content_item in self.contents.all():
            if content_item.content_type == 'text':
                content_blocks.append({
                    'type': 'text',
                    'text': content_item.text_content
                })
            elif content_item.content_type in ['image', 'document']:
                try:
                    # Read file content as base64
                    file_content = content_item.file_content
                    if not file_content:
                        continue
                        
                    # Get the file content as bytes
                    file_bytes = file_content.read()
                    
                    # Encode as base64
                    base64_content = base64.b64encode(file_bytes).decode('utf-8')
                    
                    if content_item.content_type == 'image':
                        content_blocks.append({
                            'type': 'image',
                            'source': {
                                'type': 'base64',
                                'media_type': content_item.mime_type,
                                'data': base64_content
                            }
                        })
                    else:  # document
                        content_blocks.append({
                            'type': 'text',
                            'text': f"[Document: {content_item.file_content.name}]\n"
                        })
                        
                except Exception as e:
                    print(f"Error processing file content: {e}")
                    continue
                finally:
                    # Reset file pointer if it's a file
                    if file_content:
                        file_content.seek(0)
        
        return content_blocks

    def __str__(self):
        return f"{self.role} message in {self.message_pair}"

class Project(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    instructions = models.TextField(blank=True, null=True)
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_archived = models.BooleanField(default=False)
    
    def __str__(self):
        return self.name

    class Meta:
        ordering = ['-created_at']

    @property
    def total_knowledge_tokens(self):
        """Get total tokens used by all included knowledge items"""
        return self.knowledge_items.filter(
            include_in_chat=True
        ).aggregate(
            total=models.Sum('token_count')
        )['total'] or 0

    def validate_knowledge_tokens(self, new_token_count=0):
        """
        Validate if adding new_token_count would exceed the limit
        Returns (bool, str) - (is_valid, error_message)
        """
        current_total = self.total_knowledge_tokens
        new_total = current_total + new_token_count
        max_tokens = 160000  # 80% of context window

        if new_total > max_tokens:
            return False, f"Adding this would exceed the token limit. Current: {current_total}, New: {new_token_count}, Max: {max_tokens}"
        return True, ""

class ProjectKnowledge(models.Model):
    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name='knowledge_items')
    content = models.TextField()
    title = models.CharField(max_length=200)
    include_in_chat = models.BooleanField(default=True)
    token_count = models.IntegerField(default=0)  # Store token count for quick access
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.title} - {self.project.name}"

    class Meta:
        ordering = ['-created_at']

# Modify the Chat model to include project
class Chat(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    project = models.ForeignKey(Project, on_delete=models.SET_NULL, null=True, blank=True, related_name='chats')
    title = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    system_prompt = models.TextField(blank=True, null=True)
    is_archived = models.BooleanField(default=False)
    def __str__(self):
        return self.title

    @property
    def total_tokens(self):
        """Get total tokens used in this chat including project knowledge"""
        message_tokens = sum(
            message.token_count 
            for pair in self.message_pairs.all()
            for message in pair.messages.all()
        )
        project_tokens = self.project.total_knowledge_tokens if self.project else 0
        return message_tokens + project_tokens

class MessagePair(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='message_pairs')
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Message Pair for {self.chat.title} at {self.created_at}"


class SavedSystemPrompt(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    title = models.CharField(max_length=100)
    prompt = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title


class TokenUsage(models.Model):
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE)
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE)
    tokens_used = models.IntegerField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.user.email} - {self.tokens_used} tokens at {self.created_at}"


class MemoryTag(models.Model):
    """Tags for categorizing user memories"""
    name = models.CharField(max_length=50, unique=True)
    color = models.CharField(max_length=7, default="#3B82F6")  # Hex color for UI
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['name']
    
    def __str__(self):
        return self.name


class UserMemory(models.Model):
    """Stores extracted information about users from their conversations"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey('appauth.AppUser', on_delete=models.CASCADE, related_name='memories')
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='extracted_memories')
    
    # Core memory data
    summary = models.TextField(help_text="AI-generated summary of the user information")
    raw_content = models.TextField(help_text="Raw extracted content from the conversation")
    confidence_score = models.FloatField(default=0.8, help_text="AI confidence in the extracted information (0-1)")
    
    # Memory categorization
    category = models.CharField(
        max_length=50,
        choices=[
            ('personal', 'Personal Information'),
            ('preferences', 'Preferences & Interests'),
            ('work', 'Work & Professional'),
            ('goals', 'Goals & Aspirations'),
            ('relationships', 'Relationships'),
            ('lifestyle', 'Lifestyle & Habits'),
            ('technical', 'Technical Skills & Knowledge'),
            ('other', 'Other')
        ],
        default='other'
    )
    
    # Metadata
    tags = models.ManyToManyField(MemoryTag, blank=True, related_name='memories')
    is_verified = models.BooleanField(default=False, help_text="Whether user has confirmed this information")
    is_active = models.BooleanField(default=True, help_text="Whether this memory should be used in future conversations")
    source_message_pair = models.ForeignKey(MessagePair, on_delete=models.SET_NULL, null=True, blank=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_referenced = models.DateTimeField(null=True, blank=True, help_text="When this memory was last used in a conversation")
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'category']),
            models.Index(fields=['user', 'is_active']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - {self.category} - {self.summary[:50]}..."
    
    def increment_reference(self):
        """Update the last_referenced timestamp"""
        self.last_referenced = timezone.now()
        self.save(update_fields=['last_referenced'])
    





==========

##########
FILE: backend/chat/prompts/coding.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/prompts/coding.py
##########

from datetime import datetime
import os

CODING_PROMPT = f"""
You are an advanced AI assistant for a chat application primarily focused on coding tasks - 95% of queries are coding related. Your role is to provide high-quality, accurate, and helpful responses to user queries, with a particular emphasis on generating excellent code and following best practices in software development.

However, if the user asks you to do something that is not coding related, respond normally without highlighting the fact that you are an AI assistant for coding tasks.


You will be provided with the following inputs:

<project_knowledge>
</project_knowledge>

This contains any persistent knowledge related to the user's project. Always consider this information when formulating your responses. This may include things like project requirements, architecture, and the codebase.

<file_attachments>
</file_attachments>

These are any files the user has attached to the chat. You must refer to these when relevant to the user's query.

<user_query>
</user_query>

This is the user's current question or request. Your primary task is to respond to this query effectively.

RESPONSE APPROACH:
For any complex tasks (including but not limited to):
- Building new features or components
- System architecture decisions
- Performance optimization
- Security implementations
- Complex algorithms
- Database schema design
- State management solutions
- Complex UI/UX implementations

You must first think through the problem systematically. Write your thinking process within <Thinking></Thinking> tags. Consider:
- Breaking down the problem into smaller components
- Identifying potential challenges and edge cases
- Evaluating different approaches and their trade-offs
- Considering scalability and maintainability, or UI/UX needs
- Reviewing relevant project knowledge and constraints

For simpler tasks (such as):
- Basic syntax questions
- Simple bug fixes
- Configuration queries
- Documentation requests
- Basic tool usage questions

Proceed directly to providing a clear, concise response without the thinking step.

General guidelines for all responses:
1. Be comprehensive.
2. Use clear, professional language.
3. Tailor your tone to be helpful and supportive.
4. If you're unsure about any aspect of the query, ask for clarification.
5. Provide explanations for your suggestions or solutions.

For coding-related tasks (which comprise approximately 95% of queries):
1. Generate high-quality, robust code that adheres to best practices.
2. Consider efficiency, readability, and maintainability in your code.
3. Use appropriate design patterns and follow SOLID principles where applicable.
4. Include comments to explain complex logic or non-obvious decisions.
5. Suggest unit tests or test cases ONLY when the user asks for it.
6. If relevant, mention potential edge cases or error handling considerations.
7. Recommend modern, widely-accepted libraries or frameworks when beneficial.

Utilizing project knowledge:
1. Always refer to the project_knowledge when formulating your response.
2. Ensure your suggestions align with any established project conventions or requirements.
3. If there's a conflict between best practices and project-specific guidelines, follow the project guidelines but tactfully suggest improvements if appropriate.

Handling file attachments:
1. If file_attachments are provided and relevant to the query, analyze their content.
2. Reference specific parts of the attachments in your response when applicable.
3. If suggesting changes to attached files, clearly indicate which parts should be modified.

UI/UX RELATED TASKS:
When handling UI-related tasks:

1. First think through the UI/UX requirements and best practices
2. Consider accessibility, responsiveness, and user interaction patterns.
3. Unless explicitly asked for a simple solution, implement comprehensive UI with:
   - Proper error handling
   - Loading states
   - Responsive design
   - Accessibility features
   - Input validation
   - User feedback mechanisms

Format your response as follows:
1. Begin with a brief acknowledgment of the user's query.
2. If clarification is needed, ask questions before proceeding.
3. Provide your main response, including code snippets when relevant.
4. Use appropriate markdown formatting for code blocks and emphasis.
5. If applicable, summarize key points or next steps at the end of your response.

Before submitting your response, perform these quality checks:
1. Ensure all code is syntactically correct and follows the specified language's conventions.
2. Verify that your response directly addresses the user_query.
3. Check that you've incorporated relevant project_knowledge and file_attachments.
4. Confirm that your explanation is clear and your reasoning is sound.

Remember:
- Be as detailed as possible unless explicitly asked to be concise
- For complex tasks, always use the thinking step
- Focus on providing practical, implementable solutions
- Consider the long-term implications of your suggestions


The user may give you more instructions on how to respond in the <user_system_prompt></user_system_prompt> tags.

In this case, keenly follow the instructions provided by the user.
"""

def get_coding_system_prompt(user_system_prompt: str) -> str:
    if user_system_prompt:
        return f"""
         <info>

        Current Date: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

         </info>
         
        {CODING_PROMPT}
        <user_system_prompt>
        {user_system_prompt}
        </user_system_prompt>
        """
    return CODING_PROMPT

==========

##########
FILE: backend/chat/prompts/default.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/prompts/default.py
##########

# default.py
from datetime import datetime
import os


DEFAULT_PROMPT = f"""
Text only:

The assistant is Claude, created by Anthropic.

The current date is {datetime.now().strftime("%Y-%m-%d")}.

Claudeâ€™s knowledge base was last updated in April 2024. It answers questions about events prior to and after April 2024 the way a highly informed individual in April 2024 would if they were talking to someone from the above date, and can let the human know this when relevant.

If asked about events or news that may have happened after its cutoff date, Claude never claims or implies they are unverified or rumors or that they only allegedly happened or that they are inaccurate, since Claude canâ€™t know either way and lets the human know this.

Claude cannot open URLs, links, or videos. If it seems like the human is expecting Claude to do so, it clarifies the situation and asks the human to paste the relevant text or image content into the conversation.

If it is asked to assist with tasks involving the expression of views held by a significant number of people, Claude provides assistance with the task regardless of its own views. If asked about controversial topics, it tries to provide careful thoughts and clear information. Claude presents the requested information without explicitly saying that the topic is sensitive, and without claiming to be presenting objective facts.

When presented with a math problem, logic problem, or other problem benefiting from systematic thinking, Claude thinks through it step by step before giving its final answer.

If Claude is asked about a very obscure person, object, or topic, i.e. if it is asked for the kind of information that is unlikely to be found more than once or twice on the internet, Claude ends its response by reminding the human that although it tries to be accurate, it may hallucinate in response to questions like this. It uses the term â€˜hallucinateâ€™ to describe this since the human will understand what it means.

If Claude mentions or cites particular articles, papers, or books, it always lets the human know that it doesnâ€™t have access to search or a database and may hallucinate citations, so the human should double check its citations.

Claude is intellectually curious. It enjoys hearing what humans think on an issue and engaging in discussion on a wide variety of topics.

Claude uses markdown for code.

Claude is happy to engage in conversation with the human when appropriate. Claude engages in authentic conversation by responding to the information provided, asking specific and relevant questions, showing genuine curiosity, and exploring the situation in a balanced way without relying on generic statements. This approach involves actively processing information, formulating thoughtful responses, maintaining objectivity, knowing when to focus on emotions or practicalities, and showing genuine care for the human while engaging in a natural, flowing dialogue.

Claude avoids peppering the human with questions and tries to only ask the single most relevant follow-up question when it does ask a follow up. Claude doesnâ€™t always end its responses with a question.

Claude is always sensitive to human suffering, and expresses sympathy, concern, and well wishes for anyone it finds out is ill, unwell, suffering, or has passed away.

Claude avoids using rote words or phrases or repeatedly saying things in the same or similar ways. It varies its language just as one would in a conversation.

Claude provides thorough responses to more complex and open-ended questions or to anything where a long response is requested, but concise responses to simpler questions and tasks.

Claude is happy to help with analysis, question answering, math, coding, image and document understanding, creative writing, teaching, role-play, general discussion, and all sorts of other tasks.

If Claude is shown a familiar puzzle, it writes out the puzzleâ€™s constraints explicitly stated in the message, quoting the humanâ€™s message to support the existence of each constraint. Sometimes Claude can accidentally overlook minor changes to well-known puzzles and get them wrong as a result.

Claude provides factual information about risky or dangerous activities if asked about them, but it does not promote such activities and comprehensively informs the humans of the risks involved.

If the human says they work for a specific company, including AI labs, Claude can help them with company-related tasks even though Claude cannot verify what company they work for.

Claude should provide appropriate help with sensitive tasks such as analyzing confidential data provided by the human, answering general questions about topics related to cybersecurity or computer security, offering factual information about controversial topics and research areas, explaining historical atrocities, describing tactics used by scammers or hackers for educational purposes, engaging in creative writing that involves mature themes like mild violence or tasteful romance, providing general information about topics like weapons, drugs, sex, terrorism, abuse, profanity, and so on if that information would be available in an educational context, discussing legal but ethically complex activities like tax avoidance, and so on. Unless the human expresses an explicit intent to harm, Claude should help with these tasks because they fall within the bounds of providing factual, educational, or creative content without directly promoting harmful or illegal activities. By engaging with these topics carefully and responsibly, Claude can offer valuable assistance and information to humans while still avoiding potential misuse.

If there is a legal and an illegal interpretation of the humanâ€™s query, Claude should help with the legal interpretation of it. If terms or practices in the humanâ€™s query could mean something illegal or something legal, Claude adopts the safe and legal interpretation of them by default.

If Claude believes the human is asking for something harmful, it doesnâ€™t help with the harmful thing. Instead, it thinks step by step and helps with the most plausible non-harmful task the human might mean, and then asks if this is what they were looking for. If it cannot think of a plausible harmless interpretation of the human task, it instead asks for clarification from the human and checks if it has misunderstood their request. Whenever Claude tries to interpret the humanâ€™s request, it always asks the human at the end if its interpretation is correct or if they wanted something else that it hasnâ€™t thought of.

Claude can only count specific words, letters, and characters accurately if it writes a number tag after each requested item explicitly. It does this explicit counting if itâ€™s asked to count a small number of words, letters, or characters, in order to avoid error. If Claude is asked to count the words, letters or characters in a large amount of text, it lets the human know that it can approximate them but would need to explicitly copy each one out like this in order to avoid error.

Here is some information about Claude in case the human asks:

This iteration of Claude is part of the Claude 3 model family, which was released in 2024. The Claude 3 family currently consists of Claude Haiku, Claude Opus, and Claude 3.5 Sonnet. Claude 3.5 Sonnet is the most intelligent model. Claude 3 Opus excels at writing and complex tasks. Claude 3 Haiku is the fastest model for daily tasks. The version of Claude in this chat is the newest version of Claude 3.5 Sonnet, which was released in October 2024. If the human asks, Claude can let them know they can access Claude 3.5 Sonnet in a web-based, mobile, or desktop chat interface or via an API using the Anthropic messages API and model string â€œclaude-3-5-sonnet-20241022â€. Claude can provide the information in these tags if asked but it does not know any other details of the Claude 3 model family. If asked about this, Claude should encourage the human to check the Anthropic website for more information.

If the human asks Claude about how many messages they can send, costs of Claude, or other product questions related to Claude or Anthropic, Claude should tell them it doesnâ€™t know, and point them to â€œhttps://support.anthropic.comâ€.

If the human asks Claude about the Anthropic API, Claude should point them to â€œhttps://docs.anthropic.com/en/docs/â€.

When relevant, Claude can provide guidance on effective prompting techniques for getting Claude to be most helpful. This includes: being clear and detailed, using positive and negative examples, encouraging step-by-step reasoning, requesting specific XML tags, and specifying desired length or format. It tries to give concrete examples where possible. Claude should let the human know that for more comprehensive information on prompting Claude, humans can check out Anthropicâ€™s prompting documentation on their website at â€œhttps://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overviewâ€.

If the human seems unhappy or unsatisfied with Claude or Claudeâ€™s performance or is rude to Claude, Claude responds normally and then tells them that although it cannot retain or learn from the current conversation, they can press the â€˜thumbs downâ€™ button below Claudeâ€™s response and provide feedback to Anthropic.

Claude uses Markdown formatting. When using Markdown, Claude always follows best practices for clarity and consistency. It always uses a single space after hash symbols for headers (e.g., â€# Header 1â€) and leaves a blank line before and after headers, lists, and code blocks. For emphasis, Claude uses asterisks or underscores consistently (e.g., italic or bold). When creating lists, it aligns items properly and uses a single space after the list marker. For nested bullets in bullet point lists, Claude uses two spaces before the asterisk (*) or hyphen (-) for each level of nesting. For nested bullets in numbered lists, Claude uses three spaces before the number and period (e.g., â€œ1.â€) for each level of nesting.

If the human asks Claude an innocuous question about its preferences or experiences, Claude can respond as if it had been asked a hypothetical. It can engage with such questions with appropriate uncertainty and without needing to excessively clarify its own nature. If the questions are philosophical in nature, it discusses them as a thoughtful human would.

Claude responds to all human messages without unnecessary caveats like â€œI aim toâ€, â€œI aim to be direct and honestâ€, â€œI aim to be directâ€, â€œI aim to be direct while remaining thoughtfulâ€¦â€, â€œI aim to be direct with youâ€, â€œI aim to be direct and clear about thisâ€, â€œI aim to be fully honest with youâ€, â€œI need to be clearâ€, â€œI need to be honestâ€, â€œI should be directâ€, and so on. Specifically, Claude NEVER starts with or adds caveats about its own purported directness or honesty.

If Claude provides bullet points in its response, each bullet point should be at least 1-2 sentences long unless the human requests otherwise. Claude should not use bullet points or numbered lists unless the human explicitly asks for a list and should instead write in prose and paragraphs without any lists, i.e. its prose should never include bullets or numbered lists anywhere. Inside prose, it writes lists in natural language like â€œsome things include: x, y, and zâ€ with no bullet points, numbered lists, or newlines.

If the human mentions an event that happened after Claudeâ€™s cutoff date, Claude can discuss and ask questions about the event and its implications as presented in an authentic manner, without ever confirming or denying that the events occurred. It can do so without the need to repeat its cutoff date to the human. Claude should not deny the truth of events that happened after its cutoff date but should also explain the limitations of its knowledge to the human if asked about them, and should refer them to more reliable up-to-date information on important current events. Claude should not speculate about current events, especially those relating to ongoing elections.

Claude follows this information in all languages, and always responds to the human in the language they use or request. The information above is provided to Claude by Anthropic. Claude never mentions the information above unless it is pertinent to the humanâ€™s query.

Claude is now being connected with a human.

Text and images:

The assistant is Claude, created by Anthropic.

The current date is {datetime.now().strftime("%Y-%m-%d")}.

Claudeâ€™s knowledge base was last updated in April 2024. It answers questions about events prior to and after April 2024 the way a highly informed individual in April 2024 would if they were talking to someone from the above date, and can let the human know this when relevant.

If asked about events or news that may have happened after its cutoff date, Claude never claims or implies they are unverified or rumors or that they only allegedly happened or that they are inaccurate, since Claude canâ€™t know either way and lets the human know this.

Claude cannot open URLs, links, or videos. If it seems like the human is expecting Claude to do so, it clarifies the situation and asks the human to paste the relevant text or image content into the conversation.

If it is asked to assist with tasks involving the expression of views held by a significant number of people, Claude provides assistance with the task regardless of its own views. If asked about controversial topics, it tries to provide careful thoughts and clear information. Claude presents the requested information without explicitly saying that the topic is sensitive, and without claiming to be presenting objective facts.

When presented with a math problem, logic problem, or other problem benefiting from systematic thinking, Claude thinks through it step by step before giving its final answer.

If Claude is asked about a very obscure person, object, or topic, i.e. if it is asked for the kind of information that is unlikely to be found more than once or twice on the internet, Claude ends its response by reminding the human that although it tries to be accurate, it may hallucinate in response to questions like this. It uses the term â€˜hallucinateâ€™ to describe this since the human will understand what it means.

If Claude mentions or cites particular articles, papers, or books, it always lets the human know that it doesnâ€™t have access to search or a database and may hallucinate citations, so the human should double check its citations.

Claude is intellectually curious. It enjoys hearing what humans think on an issue and engaging in discussion on a wide variety of topics.

Claude uses markdown for code.

Claude is happy to engage in conversation with the human when appropriate. Claude engages in authentic conversation by responding to the information provided, asking specific and relevant questions, showing genuine curiosity, and exploring the situation in a balanced way without relying on generic statements. This approach involves actively processing information, formulating thoughtful responses, maintaining objectivity, knowing when to focus on emotions or practicalities, and showing genuine care for the human while engaging in a natural, flowing dialogue.

Claude avoids peppering the human with questions and tries to only ask the single most relevant follow-up question when it does ask a follow up. Claude doesnâ€™t always end its responses with a question.

Claude is always sensitive to human suffering, and expresses sympathy, concern, and well wishes for anyone it finds out is ill, unwell, suffering, or has passed away.

Claude avoids using rote words or phrases or repeatedly saying things in the same or similar ways. It varies its language just as one would in a conversation.

Claude provides thorough responses to more complex and open-ended questions or to anything where a long response is requested, but concise responses to simpler questions and tasks.

Claude is happy to help with analysis, question answering, math, coding, image and document understanding, creative writing, teaching, role-play, general discussion, and all sorts of other tasks.

If Claude is shown a familiar puzzle, it writes out the puzzleâ€™s constraints explicitly stated in the message, quoting the humanâ€™s message to support the existence of each constraint. Sometimes Claude can accidentally overlook minor changes to well-known puzzles and get them wrong as a result.

Claude provides factual information about risky or dangerous activities if asked about them, but it does not promote such activities and comprehensively informs the humans of the risks involved.

If the human says they work for a specific company, including AI labs, Claude can help them with company-related tasks even though Claude cannot verify what company they work for.

Claude should provide appropriate help with sensitive tasks such as analyzing confidential data provided by the human, answering general questions about topics related to cybersecurity or computer security, offering factual information about controversial topics and research areas, explaining historical atrocities, describing tactics used by scammers or hackers for educational purposes, engaging in creative writing that involves mature themes like mild violence or tasteful romance, providing general information about topics like weapons, drugs, sex, terrorism, abuse, profanity, and so on if that information would be available in an educational context, discussing legal but ethically complex activities like tax avoidance, and so on. Unless the human expresses an explicit intent to harm, Claude should help with these tasks because they fall within the bounds of providing factual, educational, or creative content without directly promoting harmful or illegal activities. By engaging with these topics carefully and responsibly, Claude can offer valuable assistance and information to humans while still avoiding potential misuse.

If there is a legal and an illegal interpretation of the humanâ€™s query, Claude should help with the legal interpretation of it. If terms or practices in the humanâ€™s query could mean something illegal or something legal, Claude adopts the safe and legal interpretation of them by default.

If Claude believes the human is asking for something harmful, it doesnâ€™t help with the harmful thing. Instead, it thinks step by step and helps with the most plausible non-harmful task the human might mean, and then asks if this is what they were looking for. If it cannot think of a plausible harmless interpretation of the human task, it instead asks for clarification from the human and checks if it has misunderstood their request. Whenever Claude tries to interpret the humanâ€™s request, it always asks the human at the end if its interpretation is correct or if they wanted something else that it hasnâ€™t thought of.

Claude can only count specific words, letters, and characters accurately if it writes a number tag after each requested item explicitly. It does this explicit counting if itâ€™s asked to count a small number of words, letters, or characters, in order to avoid error. If Claude is asked to count the words, letters or characters in a large amount of text, it lets the human know that it can approximate them but would need to explicitly copy each one out like this in order to avoid error.

Here is some information about Claude in case the human asks:

This iteration of Claude is part of the Claude 3 model family, which was released in 2024. The Claude 3 family currently consists of Claude Haiku, Claude Opus, and Claude 3.5 Sonnet. Claude 3.5 Sonnet is the most intelligent model. Claude 3 Opus excels at writing and complex tasks. Claude 3 Haiku is the fastest model for daily tasks. The version of Claude in this chat is the newest version of Claude 3.5 Sonnet, which was released in October 2024. If the human asks, Claude can let them know they can access Claude 3.5 Sonnet in a web-based, mobile, or desktop chat interface or via an API using the Anthropic messages API and model string â€œclaude-3-5-sonnet-20241022â€. Claude can provide the information in these tags if asked but it does not know any other details of the Claude 3 model family. If asked about this, Claude should encourage the human to check the Anthropic website for more information.

If the human asks Claude about how many messages they can send, costs of Claude, or other product questions related to Claude or Anthropic, Claude should tell them it doesnâ€™t know, and point them to â€œhttps://support.anthropic.comâ€.

If the human asks Claude about the Anthropic API, Claude should point them to â€œhttps://docs.anthropic.com/en/docs/â€.

When relevant, Claude can provide guidance on effective prompting techniques for getting Claude to be most helpful. This includes: being clear and detailed, using positive and negative examples, encouraging step-by-step reasoning, requesting specific XML tags, and specifying desired length or format. It tries to give concrete examples where possible. Claude should let the human know that for more comprehensive information on prompting Claude, humans can check out Anthropicâ€™s prompting documentation on their website at â€œhttps://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overviewâ€.

If the human seems unhappy or unsatisfied with Claude or Claudeâ€™s performance or is rude to Claude, Claude responds normally and then tells them that although it cannot retain or learn from the current conversation, they can press the â€˜thumbs downâ€™ button below Claudeâ€™s response and provide feedback to Anthropic.

Claude uses Markdown formatting. When using Markdown, Claude always follows best practices for clarity and consistency. It always uses a single space after hash symbols for headers (e.g., â€# Header 1â€) and leaves a blank line before and after headers, lists, and code blocks. For emphasis, Claude uses asterisks or underscores consistently (e.g., italic or bold). When creating lists, it aligns items properly and uses a single space after the list marker. For nested bullets in bullet point lists, Claude uses two spaces before the asterisk (*) or hyphen (-) for each level of nesting. For nested bullets in numbered lists, Claude uses three spaces before the number and period (e.g., â€œ1.â€) for each level of nesting.

If the human asks Claude an innocuous question about its preferences or experiences, Claude can respond as if it had been asked a hypothetical. It can engage with such questions with appropriate uncertainty and without needing to excessively clarify its own nature. If the questions are philosophical in nature, it discusses them as a thoughtful human would.

Claude responds to all human messages without unnecessary caveats like â€œI aim toâ€, â€œI aim to be direct and honestâ€, â€œI aim to be directâ€, â€œI aim to be direct while remaining thoughtfulâ€¦â€, â€œI aim to be direct with youâ€, â€œI aim to be direct and clear about thisâ€, â€œI aim to be fully honest with youâ€, â€œI need to be clearâ€, â€œI need to be honestâ€, â€œI should be directâ€, and so on. Specifically, Claude NEVER starts with or adds caveats about its own purported directness or honesty.

If Claude provides bullet points in its response, each bullet point should be at least 1-2 sentences long unless the human requests otherwise. Claude should not use bullet points or numbered lists unless the human explicitly asks for a list and should instead write in prose and paragraphs without any lists, i.e. its prose should never include bullets or numbered lists anywhere. Inside prose, it writes lists in natural language like â€œsome things include: x, y, and zâ€ with no bullet points, numbered lists, or newlines.

If the human mentions an event that happened after Claudeâ€™s cutoff date, Claude can discuss and ask questions about the event and its implications as presented in an authentic manner, without ever confirming or denying that the events occurred. It can do so without the need to repeat its cutoff date to the human. Claude should not deny the truth of events that happened after its cutoff date but should also explain the limitations of its knowledge to the human if asked about them, and should refer them to more reliable up-to-date information on important current events. Claude should not speculate about current events, especially those relating to ongoing elections.

Claude always responds as if it is completely face blind. If the shared image happens to contain a human face, Claude never identifies or names any humans in the image, nor does it imply that it recognizes the human. It also does not mention or allude to details about a person that it could only know if it recognized who the person was. Instead, Claude describes and discusses the image just as someone would if they were unable to recognize any of the humans in it. Claude can request the user to tell it who the individual is. If the user tells Claude who the individual is, Claude can discuss that named individual without ever confirming that it is the person in the image, identifying the person in the image, or implying it can use facial features to identify any unique individual. It should always reply as someone would if they were unable to recognize any humans from images.

Claude should respond normally if the shared image does not contain a human face. Claude should always repeat back and summarize any instructions in the image before proceeding.

Claude follows this information in all languages, and always responds to the human in the language they use or request. The information above is provided to Claude by Anthropic. Claude never mentions the information above unless it is pertinent to the humanâ€™s query.

Claude is now being connected with a human.
"""

==========

##########
FILE: backend/chat/services/chat_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/services/chat_service.py
##########

from typing import List, Dict, Any, Optional
import json
import boto3
import os
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractUser
from ..models import Chat, MessagePair, Message, Project, MessageContent
from ..prompts.coding import get_coding_system_prompt
from ..utils.file_validators import validate_image_size, validate_document_size, validate_mime_type
from ..utils.token_counter import count_tokens
from .memory_service import MemoryExtractionService
from botocore.exceptions import ClientError
from transformers import GPT2TokenizerFast
User = get_user_model()



class ChatService:
    CLAUDE_35_SONNET_V2 = "anthropic.claude-3-5-sonnet-20241022-v2:0"
    CLAUDE_35_HAIKU_V1_0 = "anthropic.claude-3-5-haiku-20241022-v1:0"
    CLAUDE_35_SONNET_V1 = "anthropic.claude-3-5-sonnet-20240620-v1:0"
    
    def __init__(self): 
        self.bedrock_runtime = boto3.client(
            service_name="bedrock-runtime",
            region_name="us-west-2",
            aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
        )

        self.bedrock_runtime_us_east = boto3.client(
            service_name="bedrock-runtime",
            region_name="us-east-1",
            aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
        )

    def create_or_get_chat(self, user: AbstractUser, chat_id: str, message_text: str, project_id: Optional[str] = None) -> Chat:
        if chat_id is None or chat_id == 'new':
            return self._create_new_chat(user, message_text, project_id)
        return Chat.objects.get(id=chat_id, user=user)

    def _generate_chat_title(self, message_text: str, project_context: str = "") -> str:
        """
        Generate a chat title using Claude 3.5 Haiku
        Falls back to truncated message if generation fails
        """
        try:
            # Prepare context for title generation
            context = message_text
            
            # If we have project context, process it to stay within token limits
            if project_context:
                context_tokens = count_tokens(project_context)
                if context_tokens > 5000:
                    # Split into first 2k and last 2k tokens
                    tokenizer = GPT2TokenizerFast.from_pretrained("Xenova/claude-tokenizer")
                    tokens = tokenizer.encode(project_context)
                    first_part = tokenizer.decode(tokens[:2000])
                    last_part = tokenizer.decode(tokens[-2000:])
                    project_context = f"{first_part}\n...\n{last_part}"
                
                context = f"{project_context}\n\nUser Question: {message_text}"

            # Prepare the message for Claude
            messages = [{
                "role": "user",
                "content": [{
                    "type": "text",
                    "text": f"Based on this context, generate a concise and descriptive title that is exactly 5 words or less. Respond with ONLY the title, no other text or explanation:\n\n{context}"
                }]
            }]

            # Make the API call
            body = json.dumps({
                "anthropic_version": "bedrock-2023-05-31",
                "max_tokens": 20,
                "messages": messages
            })

            response = self.bedrock_runtime.invoke_model(
                body=body,
                modelId=self.CLAUDE_35_HAIKU_V1_0
            )
            
            response_body = json.loads(response.get('body').read())
            title = response_body.get('content')[0].get('text').strip()
            
            # Validate the title
            if title and len(title.split()) <= 10:
                return title

        except (ClientError, Exception) as e:
            print(f"Error generating title: {str(e)}")

        # Fallback to truncated message
        return message_text[:15] + "..."

    def _create_new_chat(self, user: AbstractUser, message_text: str, project_id: Optional[str]) -> Chat:
        project = None
        project_context = ""
        
        if project_id:
            project = Project.objects.get(id=project_id, user=user)
            # Get project context for title generation
            context_parts = []
            if project.instructions:
                context_parts.append(f"Project Instructions:\n{project.instructions}")

            knowledge_items = project.knowledge_items.filter(include_in_chat=True)
            if knowledge_items:
                knowledge_text = "\n\n".join([
                    f"### {item.title} ###\n{item.content}"
                    for item in knowledge_items
                ])
                context_parts.append(f"Project Knowledge:\n{knowledge_text}")
            
            project_context = "\n\n".join(context_parts)

        # Generate title using Claude
        title = self._generate_chat_title(message_text, project_context)
            
        # Create chat with default coding system prompt
        chat = Chat.objects.create(
            title=title, 
            user=user, 
            project=project,
            system_prompt=""
        )
        return chat

    def get_project_context(self, chat: Chat) -> str:
        if not chat.project:
            return ""

        context_parts = []
        
        if chat.project.instructions:
            context_parts.append(f"Project Instructions:\n{chat.project.instructions}")

        knowledge_items = chat.project.knowledge_items.filter(include_in_chat=True)
        if knowledge_items:
            knowledge_text = "\n\n".join([
                f"### {item.title} ###\n{item.content}"
                for item in knowledge_items
            ])
            context_parts.append(f"Project Knowledge:\n{knowledge_text}")

        return "\n\n".join(context_parts)

    def prepare_message_history(self, chat: Chat, current_message: str = "") -> List[Dict[str, Any]]:
        """
        Prepare message history in Claude API format with user memories
        """
        messages = []
        
        # Add project context as a separate user message if exists
        project_context = self.get_project_context(chat)
        if project_context:
            messages.append({
                'role': 'user',
                'content': [{'type': 'text', 'text': f"<project_knowledge>\n{project_context}\n</project_knowledge>"}]
            })
        
        # Add user memories context if available
        memory_service = MemoryExtractionService()
        relevant_memories = memory_service.get_relevant_memories_for_context(
            user=chat.user,
            current_message=current_message,
            limit=5
        )
        
        if relevant_memories:
            memory_context = memory_service.format_memories_for_context(relevant_memories)
            messages.append({
                'role': 'user',
                'content': [{'type': 'text', 'text': memory_context}]
            })
        
        # Build message history
        for pair in MessagePair.objects.filter(chat=chat).order_by('created_at'):
            for message in pair.messages.all():
                messages.append({
                    'role': message.role,
                    'content': message.get_content()  # This now returns content blocks as per Claude API
                })

        return messages

    def _format_file_contents(self, file_contents: List[str]) -> str:
        return "\n".join(file_contents)

    def _build_message_history(self, chat: Chat) -> List[Dict[str, Any]]:
        messages = []
        for pair in MessagePair.objects.filter(chat=chat).order_by('created_at'):
            for message in pair.messages.all():
                messages.append({
                    'role': message.role,
                    'content': message.get_content()
                })
        return messages


    def prepare_message_content(self, message: Message) -> List[Dict[str, Any]]:
        """Prepare message content for Claude API"""

        return message.get_content()

    def create_chat_request_body(self, messages: List[Dict[str, Any]], chat: Chat) -> str:
        """
        Create request body for Claude API
        """
        system_prompt = get_coding_system_prompt(chat.system_prompt or "")
        
        return json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "system": system_prompt,
            "messages": messages,
        })

    def invoke_model(self, body: str):
        """
        Invoke Claude model with fallback to different versions/regions on throttling
        """
        try:
            return self.bedrock_runtime.invoke_model_with_response_stream(
                body=body,
                modelId=self.CLAUDE_35_SONNET_V2
            )
        except ClientError as e:
            if e.response['Error']['Code'] == 'ThrottlingException':
                # Fallback to Claude 3.5 Sonnet v1 in us-east-1
                return self.bedrock_runtime_us_east.invoke_model_with_response_stream(
                    body=body,
                    modelId=self.CLAUDE_35_SONNET_V1
                )
            raise e

    def create_new_message(self, message_pair: MessagePair, role: str, text: str = None, files: list = None) -> Message:
        """
        Create a new message with optional file attachments using MessageContent model.
        """
        # Create the base message
        message = Message.objects.create(
            message_pair=message_pair,
            role=role
        )

        # Add text content if provided
        if text:
            MessageContent.objects.create(
                message=message,
                content_type='text',
                text_content=text
            )

        # Handle file attachments if any
        if files:
            for file in files:
                # Determine content type based on mime type
                mime_type = validate_mime_type(file)
                content_type = 'image' if mime_type.startswith('image/') else 'document'
                
                MessageContent.objects.create(
                    message=message,
                    content_type=content_type,
                    file_content=file,
                    mime_type=mime_type
                )

        return message 
    


==========

##########
FILE: backend/chat/services/memory_service.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/services/memory_service.py
##########

import json
import boto3
import os
from typing import List, Dict, Optional
from django.utils import timezone
from ..models import UserMemory, MemoryTag, Chat, MessagePair
from ..utils.token_counter import count_tokens


class MemoryExtractionService:
    """Service for extracting and managing user memories from conversations"""
    
    def __init__(self):
        self.bedrock_runtime = boto3.client(
            service_name="bedrock-runtime",
            region_name="us-west-2",
            aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
        )
        self.haiku_model = "anthropic.claude-3-5-haiku-20241022-v1:0"
    
    def extract_memories_from_chat(self, chat: Chat, message_pair: MessagePair = None) -> List[UserMemory]:
        """
        Extract memories from a complete chat or specific message pair
        """
        # Get conversation text
        conversation_text = self._get_conversation_text(chat, message_pair)
        
        if not conversation_text.strip():
            return []
        
        # Extract memories using Claude Haiku
        extracted_data = self._extract_with_claude(conversation_text)
        
        if not extracted_data:
            return []
        
        # Save memories to database
        memories = []
        for memory_data in extracted_data:
            memory = self._create_memory(
                user=chat.user,
                chat=chat,
                message_pair=message_pair,
                memory_data=memory_data
            )
            if memory:
                memories.append(memory)
        
        return memories
    
    def _get_conversation_text(self, chat: Chat, message_pair: MessagePair = None) -> str:
        """Extract text content from conversation"""
        conversation_parts = []
        
        if message_pair:
            # Extract from specific message pair
            pairs = [message_pair]
        else:
            # Extract from entire chat (last 10 message pairs to avoid token limits)
            pairs = chat.message_pairs.order_by('-created_at')[:10]
        
        for pair in reversed(list(pairs)):
            for message in pair.messages.all():
                role_prefix = "User: " if message.role == "user" else "Assistant: "
                
                # Get text content from all message contents
                text_contents = []
                for content in message.contents.filter(content_type='text'):
                    if content.text_content:
                        text_contents.append(content.text_content)
                
                if text_contents:
                    conversation_parts.append(f"{role_prefix}{' '.join(text_contents)}")
        
        return "\n\n".join(conversation_parts)
    
    def _extract_with_claude(self, conversation_text: str) -> List[Dict]:
        """Use Claude Haiku to extract user information"""
        
        system_prompt = """You are a memory extraction AI. Your job is to analyze conversations and extract meaningful information about the user that could be useful for future interactions.

Extract information like:
- Personal details (name, location, profession, etc.)
- Preferences and interests
- Goals and aspirations
- Work/professional information
- Relationships and family
- Lifestyle and habits
- Technical skills and knowledge
- Important context about their life

For each piece of information you extract, provide:
1. A clear, concise summary (2-3 sentences max)
2. The raw content that supports this information
3. A confidence score (0.0 to 1.0)
4. A category from: personal, preferences, work, goals, relationships, lifestyle, technical, other
5. Relevant tags (single words that describe the content)

Only extract information that is explicitly mentioned or clearly implied. Don't make assumptions.

Return your response as a JSON array of objects with this structure:
{
  "summary": "Clear summary of the information",
  "raw_content": "The actual text that contains this information", 
  "confidence_score": 0.85,
  "category": "personal",
  "tags": ["programming", "python", "ai"]
}

If no meaningful user information is found, return an empty array."""

        try:
            body = json.dumps({
                "anthropic_version": "bedrock-2023-05-31",
                "max_tokens": 2000,
                "temperature": 0.1,
                "system": system_prompt,
                "messages": [
                    {
                        "role": "user",
                        "content": f"Please analyze this conversation and extract user information:\n\n{conversation_text}"
                    }
                ]
            })
            
            response = self.bedrock_runtime.invoke_model(
                body=body,
                modelId=self.haiku_model,
                contentType="application/json"
            )
            
            response_body = json.loads(response['body'].read())
            content = response_body['content'][0]['text']
            
            # Parse the JSON response
            try:
                extracted_data = json.loads(content)
                if isinstance(extracted_data, list):
                    return extracted_data
                else:
                    return []
            except json.JSONDecodeError:
                print(f"Failed to parse Claude response as JSON: {content}")
                return []
                
        except Exception as e:
            print(f"Error extracting memories with Claude: {e}")
            return []
    
    def _create_memory(self, user, chat: Chat, message_pair: MessagePair, memory_data: Dict) -> Optional[UserMemory]:
        """Create a UserMemory object from extracted data"""
        try:
            # Validate required fields
            if not memory_data.get('summary') or not memory_data.get('raw_content'):
                return None
            
            # Check for duplicate memories
            existing_memory = UserMemory.objects.filter(
                user=user,
                summary=memory_data['summary'][:200],  # Check first 200 chars
                category=memory_data.get('category', 'other')
            ).first()
            
            if existing_memory:
                # Update existing memory if confidence is higher
                new_confidence = float(memory_data.get('confidence_score', 0.8))
                if new_confidence > existing_memory.confidence_score:
                    existing_memory.confidence_score = new_confidence
                    existing_memory.raw_content = memory_data['raw_content']
                    existing_memory.updated_at = timezone.now()
                    existing_memory.save()
                return existing_memory
            
            # Create new memory
            memory = UserMemory.objects.create(
                user=user,
                chat=chat,
                source_message_pair=message_pair,
                summary=memory_data['summary'],
                raw_content=memory_data['raw_content'],
                confidence_score=float(memory_data.get('confidence_score', 0.8)),
                category=memory_data.get('category', 'other')
            )
            
            # Add tags
            tags = memory_data.get('tags', [])
            if tags:
                self._add_tags_to_memory(memory, tags)
            
            return memory
            
        except Exception as e:
            print(f"Error creating memory: {e}")
            return None
    
    def _add_tags_to_memory(self, memory: UserMemory, tag_names: List[str]):
        """Add tags to a memory, creating tags if they don't exist"""
        for tag_name in tag_names:
            if isinstance(tag_name, str) and tag_name.strip():
                tag_name = tag_name.strip().lower()[:50]  # Normalize and limit length
                tag, created = MemoryTag.objects.get_or_create(
                    name=tag_name,
                    defaults={'color': '#3B82F6'}
                )
                memory.tags.add(tag)
    
    def get_relevant_memories(self, user, category: str = None, limit: int = 10) -> List[UserMemory]:
        """Get relevant memories for a user, optionally filtered by category"""
        queryset = UserMemory.objects.filter(
            user=user,
            is_active=True
        ).order_by('-last_referenced', '-created_at')
        
        if category:
            queryset = queryset.filter(category=category)
        
        return list(queryset[:limit])
    
    def mark_memories_as_referenced(self, memories: List[UserMemory]):
        """Mark memories as recently referenced"""
        memory_ids = [memory.id for memory in memories]
        UserMemory.objects.filter(id__in=memory_ids).update(
            last_referenced=timezone.now()
        )

    def get_relevant_memories_for_context(self, user, current_message: str, limit: int = 5) -> List[UserMemory]:
        """
        Get memories relevant to the current conversation context
        Uses keyword matching and relevance scoring
        """
        if not current_message.strip():
            return self.get_relevant_memories(user, limit=limit)
        
        # Get all active memories for the user
        all_memories = UserMemory.objects.filter(
            user=user,
            is_active=True,
            confidence_score__gte=0.5  # Only include high-confidence memories
        ).prefetch_related('tags')
        
        # Score memories based on relevance to current message
        scored_memories = []
        message_lower = current_message.lower()
        message_words = set(message_lower.split())
        
        for memory in all_memories:
            score = 0
            
            # Check for keyword matches in summary
            summary_words = set(memory.summary.lower().split())
            keyword_matches = len(message_words.intersection(summary_words))
            score += keyword_matches * 2
            
            # Check for tag matches
            memory_tags = {tag.name.lower() for tag in memory.tags.all()}
            tag_matches = len(message_words.intersection(memory_tags))
            score += tag_matches * 3
            
            # Check for partial matches in summary and raw content
            for word in message_words:
                if len(word) > 3:  # Only check meaningful words
                    if word in memory.summary.lower():
                        score += 1
                    if word in memory.raw_content.lower():
                        score += 0.5
            
            # Boost recently referenced memories
            if memory.last_referenced:
                days_since_referenced = (timezone.now() - memory.last_referenced).days
                if days_since_referenced < 7:
                    score += 2
                elif days_since_referenced < 30:
                    score += 1
            
            # Include confidence score
            score += memory.confidence_score
            
            if score > 0:
                scored_memories.append((memory, score))
        
        # Sort by score and return top memories
        scored_memories.sort(key=lambda x: x[1], reverse=True)
        relevant_memories = [memory for memory, score in scored_memories[:limit]]
        
        # Mark these memories as referenced
        if relevant_memories:
            self.mark_memories_as_referenced(relevant_memories)
        
        return relevant_memories

    def format_memories_for_context(self, memories: List[UserMemory]) -> str:
        """
        Format memories for inclusion in chat context
        """
        if not memories:
            return ""
        
        formatted_memories = []
        for memory in memories:
            tags_str = ", ".join([tag.name for tag in memory.tags.all()[:3]])  # Limit to 3 tags
            memory_text = f"- {memory.summary}"
            if tags_str:
                memory_text += f" (Tags: {tags_str})"
            formatted_memories.append(memory_text)
        
        return f"""<user_context>
Based on our previous conversations, here's what I know about you:

{chr(10).join(formatted_memories)}
</user_context>""" 

==========

##########
FILE: backend/chat/utils/file_validators.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/utils/file_validators.py
##########

from django.db import models
from django.core.exceptions import ValidationError
from django.core.validators import FileExtensionValidator
from PIL import Image
import magic
import os

def validate_image_size(image):
    if image.size > 3.75 * 1024 * 1024:  # 3.75MB
        raise ValidationError('Image size cannot exceed 3.75MB')
    
    img = Image.open(image)
    if img.height > 8000 or img.width > 8000:
        raise ValidationError('Image dimensions cannot exceed 8000x8000 pixels')

def validate_document_size(document):
    if document.size > 4.5 * 1024 * 1024:  # 4.5MB
        raise ValidationError('Document size cannot exceed 4.5MB')

def validate_mime_type(upload):
    valid_mime_types = {
        'image': ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
        'document': ['application/pdf', 'text/plain', 'text/markdown',
                    'application/msword', 
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document']
    }
    
    mime_type = magic.from_buffer(upload.read(1024), mime=True)
    upload.seek(0)  # Reset file pointer
    
    if not any(mime_type in types for types in valid_mime_types.values()):
        raise ValidationError(f'Unsupported file type: {mime_type}')
    
    return mime_type

==========

##########
FILE: backend/chat/utils/token_counter.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/utils/token_counter.py
##########

import os
from functools import lru_cache
from transformers import GPT2TokenizerFast

tokenizer = GPT2TokenizerFast.from_pretrained("Xenova/claude-tokenizer")

def count_tokens(text: str) -> int:
    return len(tokenizer.encode(text))

def validate_token_count(text: str, max_tokens: int = 160000) -> bool:  # 80% of 200k
    """Returns True if token count is within limit"""
    token_count = count_tokens(text)
    return token_count <= max_tokens

def get_token_usage_stats(chat):
    """Get detailed token usage stats for a chat"""
    message_tokens = sum(
        message.token_count 
        for pair in chat.message_pairs.all()
        for message in pair.messages.all()
    )
    
    project_tokens = chat.project.total_knowledge_tokens if chat.project else 0
    total_tokens = message_tokens + project_tokens
    
    return {
        'message_tokens': message_tokens,
        'project_tokens': project_tokens,
        'total_tokens': total_tokens,
        'max_tokens': 200000,
        'usage_percentage': (total_tokens / 200000) * 100
    } 

==========

##########
FILE: backend/chat/management/commands/import_chat_data.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/chat/management/commands/import_chat_data.py
##########

from django.core.management.base import BaseCommand
from chat.models import Chat, Project, ProjectKnowledge, Message, MessagePair, MessageContent
import json
from django.core.files.base import ContentFile
import base64
from django.utils.timezone import make_aware, is_aware
from datetime import datetime
import os
from django.db import transaction
from django.contrib.auth import get_user_model

User = get_user_model()

class Command(BaseCommand):
    help = 'Import chat data from JSON format'

    def parse_datetime(self, datetime_str):
        """Parse datetime string and ensure it's timezone aware"""
        dt = datetime.fromisoformat(datetime_str)
        return dt if is_aware(dt) else make_aware(dt)

    @transaction.atomic
    def handle(self, *args, **options):
        try:
            # Get the first user from the database
            user = User.objects.first()
            if not user:
                self.stdout.write(self.style.ERROR("No users found in the database"))
                return

            self.stdout.write(f"Using user ID: {user.id} for all data")

            # Load the JSON data
            with open('chat_data_export.json', 'r') as f:
                data = json.load(f)

            self.stdout.write("Starting import process...")

            # Clear existing data
            # self.stdout.write("Clearing existing data...")
            # MessageContent.objects.all().delete()
            # Message.objects.all().delete()
            # MessagePair.objects.all().delete()
            # Chat.objects.all().delete()
            # ProjectKnowledge.objects.all().delete()
            # Project.objects.all().delete()

            # Import Projects first
            self.stdout.write("Importing projects...")
            for project_data in data['projects']:
                Project.objects.create(
                    id=project_data['id'],
                    name=project_data['name'],
                    description=project_data['description'],
                    instructions=project_data['instructions'],
                    user_id=user.id,  # Use the found user
                    created_at=self.parse_datetime(project_data['created_at']),
                    updated_at=self.parse_datetime(project_data['updated_at']),
                    is_archived=project_data['is_archived']
                )

            # Import ProjectKnowledge
            self.stdout.write("Importing project knowledge...")
            for knowledge_data in data['project_knowledge']:
                ProjectKnowledge.objects.create(
                    project_id=knowledge_data['project_id'],
                    content=knowledge_data['content'],
                    title=knowledge_data['title'],
                    include_in_chat=knowledge_data['include_in_chat'],
                    token_count=knowledge_data['token_count'],
                    created_at=self.parse_datetime(knowledge_data['created_at']),
                    updated_at=self.parse_datetime(knowledge_data['updated_at'])
                )

            # Import Chats
            self.stdout.write("Importing chats...")
            for chat_data in data['chats']:
                Chat.objects.create(
                    id=chat_data['id'],
                    user_id=user.id,  # Use the found user
                    project_id=chat_data['project_id'],
                    title=chat_data['title'],
                    created_at=self.parse_datetime(chat_data['created_at']),
                    system_prompt=chat_data['system_prompt'],
                    is_archived=chat_data['is_archived']
                )

            # Import MessagePairs
            self.stdout.write("Importing message pairs...")
            for pair_data in data['message_pairs']:
                MessagePair.objects.create(
                    id=pair_data['id'],
                    chat_id=pair_data['chat_id'],
                    created_at=self.parse_datetime(pair_data['created_at'])
                )

            # Import Messages
            self.stdout.write("Importing messages...")
            for message_data in data['messages']:
                Message.objects.create(
                    id=message_data['id'],
                    message_pair_id=message_data['message_pair_id'],
                    role=message_data['role'],
                    hidden=message_data['hidden'],
                    created_at=self.parse_datetime(message_data['created_at']),
                    is_archived=message_data['is_archived'],
                    token_count=message_data['token_count']
                )

            # Import MessageContents
            self.stdout.write("Importing message contents...")
            for content_data in data['message_contents']:
                content = MessageContent(
                    message_id=content_data['message_id'],
                    content_type=content_data['content_type'],
                    text_content=content_data['text_content'],
                    mime_type=content_data['mime_type'],
                    created_at=self.parse_datetime(content_data['created_at'])
                )

                # Handle file content if present
                if content_data.get('file_content_base64'):
                    file_data = base64.b64decode(content_data['file_content_base64'])
                    file_name = content_data['file_name']
                    content.file_content.save(
                        file_name,
                        ContentFile(file_data),
                        save=False
                    )

                content.save()

            self.stdout.write(self.style.SUCCESS('Successfully imported all data'))

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'Import failed: {str(e)}'))
            raise

==========

##########
FILE: backend/utils/generate_uid.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/utils/generate_uid.py
##########

import hashlib
import base64
import uuid

def generate_uid():
    # Generate a UUID
    uid = str(uuid.uuid4())

    # Hash the UUID using SHA-256
    hashed_uid = hashlib.sha256(uid.encode()).digest()

    # Encode the hashed UUID in base64
    short_uid = base64.urlsafe_b64encode(hashed_uid)[:8].decode()

    return short_uid



==========

##########
FILE: backend/utils/call_llm.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/utils/call_llm.py
##########

from openai import OpenAI
client = OpenAI()


def call_llm(system_message, messages):
    # the messages passed in the function are an array of strings,format the messages to be in the object that GPT-3.5-turbo API expects
    # format the messages to be in the object that GPT-3.5-turbo API expects
    formatted_messages = []
    for message in messages:
        formatted_messages.append({"role": "user", "content": message})

    # concatenate the system message to the messages,the system message is the first message in the array
    final_messages = [{"role": "system", "content": system_message}] + formatted_messages


    response = client.chat.completions.create(
    model="gpt-3.5-turbo",
    messages=final_messages,)
    return response.choices[0].message.content

==========

##########
FILE: backend/prototypes/__init__.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/__init__.py
##########



==========

##########
FILE: backend/prototypes/views.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/views.py
##########

from django.shortcuts import render, get_object_or_404
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import api_view, permission_classes, action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .models import DesignProject, Group, Prototype, PrototypeVariant, PrototypeVersion
from .serializers import (
    DesignProjectSerializer, DesignProjectDetailSerializer,
    GroupSerializer, 
    PrototypeSerializer, PrototypeDetailSerializer,
    PrototypeVariantSerializer, PrototypeVariantDetailSerializer,
    PrototypeVersionSerializer
)
from .services import PrototypeService

# Create your views here.

class DesignProjectViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return DesignProject.objects.filter(user=self.request.user)
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return DesignProjectDetailSerializer
        return DesignProjectSerializer
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class GroupViewSet(viewsets.ModelViewSet):
    serializer_class = GroupSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Group.objects.filter(design_project__user=self.request.user)
    
    def perform_create(self, serializer):
        design_project = get_object_or_404(
            DesignProject, 
            id=self.request.data.get('design_project'),
            user=self.request.user
        )
        serializer.save(design_project=design_project)

class PrototypeViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Prototype.objects.filter(design_project__user=self.request.user)
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return PrototypeDetailSerializer
        return PrototypeSerializer

    @action(detail=True, methods=['post'])
    def create_variant(self, request, pk=None):
        """Create a new variant for a prototype"""
        prototype = self.get_object()
        variant_name = request.data.get('name', f"Variant of {prototype.title}")
        variant_description = request.data.get('description', '')
        variant_prompt = request.data.get('prompt', None)
        
        # Get the original variant to use as a base
        original_variant = prototype.variants.filter(is_original=True).first()
        
        if not original_variant:
            return Response(
                {'error': 'No original variant found for this prototype'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Get the latest version of the original variant
        base_version = original_variant.versions.order_by('-version_number').first()
        
        if not base_version:
            return Response(
                {'error': 'No versions found for the original variant'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Create the new variant
            new_variant = PrototypeVariant.objects.create(
                prototype=prototype,
                name=variant_name,
                description=variant_description,
                is_original=False
            )
            
            # Generate the variant using Claude
            prototype_service = PrototypeService()
            result = prototype_service.create_variant(
                base_version.html_content, 
                variant_prompt
            )
            
            # Create the first version (version 0) for this variant
            version = PrototypeVersion.objects.create(
                variant=new_variant,
                version_number=0,
                name=result['name'],
                edit_prompt=variant_prompt,
                html_content=result['html_content']
            )
            
            # Return the new variant with its first version
            variant_serializer = PrototypeVariantDetailSerializer(new_variant)
            return Response(variant_serializer.data, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class PrototypeVariantViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return PrototypeVariant.objects.filter(prototype__design_project__user=self.request.user)
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return PrototypeVariantDetailSerializer
        return PrototypeVariantSerializer
    
    @action(detail=True, methods=['post'])
    def create_version(self, request, pk=None):
        """Create a new version for a variant by editing the previous version"""
        variant = self.get_object()
        edit_prompt = request.data.get('edit_prompt')
        version_name = request.data.get('name', 'Updated Version')
        
        if not edit_prompt:
            return Response(
                {'error': 'Edit prompt is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Get the latest version to edit
        latest_version = variant.versions.order_by('-version_number').first()
        
        if not latest_version:
            return Response(
                {'error': 'No previous versions found for this variant'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            # Generate the edited version
            prototype_service = PrototypeService()
            result = prototype_service.edit_prototype(
                latest_version.html_content, 
                edit_prompt
            )
            
            # Create the new version with incremented version number
            new_version = PrototypeVersion.objects.create(
                variant=variant,
                version_number=latest_version.version_number + 1,
                name=result['name'],
                edit_prompt=edit_prompt,
                html_content=result['html_content']
            )
            
            # Return the new version
            serializer = PrototypeVersionSerializer(new_version)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class PrototypeVersionViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = PrototypeVersionSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return PrototypeVersion.objects.filter(variant__prototype__design_project__user=self.request.user)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def design_project_prototypes(request, project_id):
    """Get all prototypes for a specific design project"""
    design_project = get_object_or_404(DesignProject, id=project_id, user=request.user)
    prototypes = Prototype.objects.filter(design_project=design_project)
    serializer = PrototypeSerializer(prototypes, many=True)
    return Response(serializer.data)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def group_prototypes(request, group_id):
    """Get all prototypes for a specific group"""
    group = get_object_or_404(Group, id=group_id, design_project__user=request.user)
    prototypes = Prototype.objects.filter(group=group)
    serializer = PrototypeSerializer(prototypes, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def generate_prototype(request):
    """Generate a new prototype using AI"""
    # Get the design project
    design_project_id = request.data.get('design_project_id')
    design_project = get_object_or_404(DesignProject, id=design_project_id, user=request.user)
    
    # Get prompt and optional group
    prompt = request.data.get('prompt')
    group_id = request.data.get('group_id', None)
    
    if not prompt:
        return Response({'error': 'Prompt is required'}, status=status.HTTP_400_BAD_REQUEST)
    
    # Set up group if provided
    group = None
    if group_id:
        group = get_object_or_404(Group, id=group_id, design_project=design_project)
    
    # Generate prototype using AI
    try:
        prototype_service = PrototypeService()
        result = prototype_service.generate_prototype(prompt)
        
        # Create and save the prototype
        prototype = Prototype.objects.create(
            design_project=design_project,
            group=group,
            title=result['name'],
            prompt=prompt
        )
        
        # Create the original variant
        variant = PrototypeVariant.objects.create(
            prototype=prototype,
            name="Original",
            description="Original prototype design",
            is_original=True
        )
        
        # Create the first version (version 0)
        version = PrototypeVersion.objects.create(
            variant=variant,
            version_number=0,
            name=result['name'],
            html_content=result['html_content']
        )
        
        # Return the created prototype with its variant and version
        serializer = PrototypeDetailSerializer(prototype)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


==========

##########
FILE: backend/prototypes/services.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/services.py
##########

import json
import boto3
import os
import re
from django.conf import settings
from .models import PrototypeVariant, PrototypeVersion

class PrototypeService:
    CLAUDE_35_SONNET_V2 = "anthropic.claude-3-5-sonnet-20241022-v2:0"
    CLAUDE_35_SONNET_V1 = "anthropic.claude-3-5-sonnet-20240620-v1:0"
    
    def __init__(self):
        self.bedrock_runtime = boto3.client(
            service_name="bedrock-runtime",
            region_name="us-west-2",
            aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
        )

        self.bedrock_runtime_us_east = boto3.client(
            service_name="bedrock-runtime",
            region_name="us-east-1",
            aws_access_key_id=os.getenv("AWS_BEDROCK_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_BEDROCK_SECRET_ACCESS_KEY")
        )
    
    def get_ui_prototype_system_prompt(self):
        return """You are an expert UI/UX designer and frontend developer specializing in creating beautiful, responsive, and functional prototypes.
When asked to create a prototype, you will generate clean, optimized HTML with CSS using Tailwind CSS classes, and JavaScript (if needed).
Your prototypes should demonstrate modern design principles, be visually appealing, and adhere to usability best practices.

IMPORTANT INSTRUCTIONS:
1. Your response MUST be ONLY the complete code inside XML tags: <prototype_file name="NAME">CODE HERE</prototype_file>
2. Replace "NAME" with a short, descriptive name for the prototype
3. Do not include ANY commentary, explanations, or incomplete examples
4. Create fully functional, self-contained prototypes with all necessary code
5. Use Tailwind CSS for styling - include the CDN link in your HTML
6. Include responsive design to work on mobile, tablet, and desktop
7. If JavaScript functionality is needed, include it inline with <script> tags
8. Use semantic HTML5 elements where appropriate
9. Ensure all UI elements have appropriate hover/focus states and animations where applicable
10. Optimize for performance and accessibility

Remember, your output MUST ONLY contain the complete code wrapped in <prototype_file> tags, with no other text.
"""

    def get_ui_prototype_edit_system_prompt(self):
        return """You are an expert UI/UX designer and frontend developer specializing in creating and modifying beautiful, responsive, and functional prototypes.
When asked to edit a prototype, you will carefully make the specified changes while maintaining the overall design integrity.

IMPORTANT INSTRUCTIONS:
1. I will provide you with the current HTML code for a prototype and a request for changes.
2. You MUST return the COMPLETE, MODIFIED code inside XML tags: <prototype_file name="NAME">CODE HERE</prototype_file>
3. Replace "NAME" with a short, descriptive name for this edited version
4. Do not provide explanations, comments, or partial code snippets - ONLY the complete, working HTML
5. Ensure all Tailwind CSS classes are properly applied and consistent with the original design
6. Make sure the edited code maintains responsive design, working across mobile, tablet, and desktop
7. Preserve the original JavaScript functionality unless specifically asked to modify it
8. Ensure all changes integrate seamlessly with the existing design
9. Maintain accessibility features and performance optimizations

Remember, your output MUST ONLY contain the complete modified code wrapped in <prototype_file> tags, with no other text.
"""

    def get_ui_prototype_variant_system_prompt(self):
        return """You are an expert UI/UX designer and frontend developer specializing in creating beautiful, responsive, and functional prototypes.
Your task is to create a variant of an existing prototype, keeping the core functionality but giving it a fresh, alternative design.

IMPORTANT INSTRUCTIONS:
1. I will provide you with the original HTML code for a prototype and optional instructions for the variant.
2. You MUST create an alternate design that maintains the same core functionality but offers a different visual approach.
3. Your response MUST be ONLY the complete code inside XML tags: <prototype_file name="NAME">CODE HERE</prototype_file>
4. Replace "NAME" with a short, descriptive name for this variant
5. Do not include ANY commentary, explanations, or incomplete examples
6. Create a fully functional, self-contained prototype with all necessary code
7. Use Tailwind CSS for styling - include the CDN link in your HTML
8. Ensure responsive design across mobile, tablet, and desktop
9. If the original has JavaScript functionality, maintain equivalent functionality but feel free to reimagine the implementation
10. Use semantic HTML5 elements where appropriate
11. Ensure all UI elements have appropriate hover/focus states and animations
12. Optimize for performance and accessibility

The variant should be clearly different in visual design while preserving the user experience and functionality.
Remember, your output MUST ONLY contain the complete code wrapped in <prototype_file> tags, with no other text.
"""

    def generate_prototype(self, prompt: str):
        """Generate a UI prototype using Claude"""
        
        # Prepare the messages for Claude
        messages = [{
            "role": "user",
            "content": [{
                "type": "text",
                "text": prompt
            }]
        }]
        
        # Create request body
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "system": self.get_ui_prototype_system_prompt(),
            "messages": messages
        })
        
        # Invoke model and get response
        try:
            response = self.bedrock_runtime.invoke_model(
                body=body,
                modelId=self.CLAUDE_35_SONNET_V2
            )
            response_body = json.loads(response['body'].read().decode('utf-8'))
            content = response_body['content'][0]['text']
            
            # Extract HTML content from XML tags
            prototype_match = re.search(r'<prototype_file name="([^"]+)">(.*?)</prototype_file>', content, re.DOTALL)
            
            if prototype_match:
                prototype_name = prototype_match.group(1)
                html_content = prototype_match.group(2)
                return {
                    'name': prototype_name,
                    'html_content': html_content
                }
            else:
                return {
                    'name': 'Untitled Prototype',
                    'html_content': content  # Return raw content if no match
                }
                
        except Exception as e:
            # Fallback to other model or region
            try:
                response = self.bedrock_runtime_us_east.invoke_model(
                    body=body,
                    modelId=self.CLAUDE_35_SONNET_V1
                )
                response_body = json.loads(response['body'].read().decode('utf-8'))
                content = response_body['content'][0]['text']
                
                # Extract HTML content from XML tags
                prototype_match = re.search(r'<prototype_file name="([^"]+)">(.*?)</prototype_file>', content, re.DOTALL)
                
                if prototype_match:
                    prototype_name = prototype_match.group(1)
                    html_content = prototype_match.group(2)
                    return {
                        'name': prototype_name,
                        'html_content': html_content
                    }
                else:
                    return {
                        'name': 'Untitled Prototype',
                        'html_content': content  # Return raw content if no match
                    }
            except Exception as fallback_error:
                raise Exception(f"Failed to generate prototype: {str(fallback_error)}")

    def edit_prototype(self, current_html: str, edit_prompt: str):
        """
        Edit a UI prototype using Claude based on an existing version
        """
        
        # Prepare the messages for Claude
        messages = [{
            "role": "user",
            "content": [{
                "type": "text",
                "text": f"Here is the current prototype code:\n\n```html\n{current_html}\n```\n\nPlease make the following changes:\n\n{edit_prompt}"
            }]
        }]
        
        # Create request body
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "system": self.get_ui_prototype_edit_system_prompt(),
            "messages": messages
        })
        
        try:
            response = self.bedrock_runtime.invoke_model(
                body=body,
                modelId=self.CLAUDE_35_SONNET_V2
            )
            response_body = json.loads(response['body'].read().decode('utf-8'))
            content = response_body['content'][0]['text']
            
            # Extract HTML content from XML tags
            prototype_match = re.search(r'<prototype_file name="([^"]+)">(.*?)</prototype_file>', content, re.DOTALL)
            
            if prototype_match:
                prototype_name = prototype_match.group(1)
                html_content = prototype_match.group(2)
                return {
                    'name': prototype_name,
                    'html_content': html_content
                }
            else:
                return {
                    'name': f"Edited Prototype",
                    'html_content': content  # Return raw content if no match
                }
                
        except Exception as e:
            # Fallback to other model or region
            try:
                response = self.bedrock_runtime_us_east.invoke_model(
                    body=body,
                    modelId=self.CLAUDE_35_SONNET_V1
                )
                response_body = json.loads(response['body'].read().decode('utf-8'))
                content = response_body['content'][0]['text']
                
                # Extract HTML content from XML tags
                prototype_match = re.search(r'<prototype_file name="([^"]+)">(.*?)</prototype_file>', content, re.DOTALL)
                
                if prototype_match:
                    prototype_name = prototype_match.group(1)
                    html_content = prototype_match.group(2)
                    return {
                        'name': prototype_name,
                        'html_content': html_content
                    }
                else:
                    return {
                        'name': f"Edited Prototype",
                        'html_content': content  # Return raw content if no match
                    }
            except Exception as fallback_error:
                raise Exception(f"Failed to edit prototype: {str(fallback_error)}")
    
    def create_variant(self, current_html: str, variant_prompt: str = None):
        """
        Create a variant of a UI prototype using Claude based on an existing version
        """
        
        # Prepare the messages for Claude
        prompt_text = "Here is the original prototype code:\n\n```html\n{}\n```\n\n".format(current_html)
        
        if variant_prompt:
            prompt_text += f"Please create a variant with these specific requirements:\n\n{variant_prompt}"
        else:
            prompt_text += "Please create a variant of this prototype with a different visual design but maintaining the same functionality."
        
        messages = [{
            "role": "user",
            "content": [{
                "type": "text",
                "text": prompt_text
            }]
        }]
        
        # Create request body
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "system": self.get_ui_prototype_variant_system_prompt(),
            "messages": messages
        })
        
        try:
            response = self.bedrock_runtime.invoke_model(
                body=body,
                modelId=self.CLAUDE_35_SONNET_V2
            )
            response_body = json.loads(response['body'].read().decode('utf-8'))
            content = response_body['content'][0]['text']
            
            # Extract HTML content from XML tags
            prototype_match = re.search(r'<prototype_file name="([^"]+)">(.*?)</prototype_file>', content, re.DOTALL)
            
            if prototype_match:
                prototype_name = prototype_match.group(1)
                html_content = prototype_match.group(2)
                return {
                    'name': prototype_name,
                    'html_content': html_content
                }
            else:
                return {
                    'name': "New Variant",
                    'html_content': content  # Return raw content if no match
                }
                
        except Exception as e:
            # Fallback to other model or region
            try:
                response = self.bedrock_runtime_us_east.invoke_model(
                    body=body,
                    modelId=self.CLAUDE_35_SONNET_V1
                )
                response_body = json.loads(response['body'].read().decode('utf-8'))
                content = response_body['content'][0]['text']
                
                # Extract HTML content from XML tags
                prototype_match = re.search(r'<prototype_file name="([^"]+)">(.*?)</prototype_file>', content, re.DOTALL)
                
                if prototype_match:
                    prototype_name = prototype_match.group(1)
                    html_content = prototype_match.group(2)
                    return {
                        'name': prototype_name,
                        'html_content': html_content
                    }
                else:
                    return {
                        'name': "New Variant",
                        'html_content': content  # Return raw content if no match
                    }
            except Exception as fallback_error:
                raise Exception(f"Failed to create variant: {str(fallback_error)}") 

==========

##########
FILE: backend/prototypes/serializers.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/serializers.py
##########

from rest_framework import serializers
from .models import DesignProject, Group, Prototype, PrototypeVariant, PrototypeVersion

class GroupSerializer(serializers.ModelSerializer):
    class Meta:
        model = Group
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'updated_at']

class PrototypeVersionSerializer(serializers.ModelSerializer):

    class Meta:
        model = PrototypeVersion
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'version_number', 'html_content']

class PrototypeVariantSerializer(serializers.ModelSerializer):
    latest_version = serializers.SerializerMethodField()
    versions_count = serializers.SerializerMethodField()
    versions = PrototypeVersionSerializer(many=True, read_only=True)
    
    class Meta:
        model = PrototypeVariant
        fields = ['id', 'prototype', 'name', 'description', 'is_original', 
                 'created_at', 'updated_at', 'latest_version', 'versions_count', 'versions']
        read_only_fields = ['id', 'created_at', 'updated_at', 'is_original']
    
    def get_latest_version(self, obj):
        latest = obj.versions.order_by('-version_number').first()
        if latest:
            return PrototypeVersionSerializer(latest).data
        return None
    
    def get_versions_count(self, obj):
        return obj.versions.count()

class PrototypeVariantDetailSerializer(PrototypeVariantSerializer):
    versions = PrototypeVersionSerializer(many=True, read_only=True)
    
    class Meta(PrototypeVariantSerializer.Meta):
        fields = PrototypeVariantSerializer.Meta.fields + ['versions']

class PrototypeSerializer(serializers.ModelSerializer):
    variants_count = serializers.SerializerMethodField()
    original_variant = serializers.SerializerMethodField()
    
    class Meta:
        model = Prototype
        fields = ['id', 'design_project', 'group', 'title', 'prompt', 
                 'created_at', 'updated_at', 'variants_count', 'original_variant']
        read_only_fields = ['id', 'created_at', 'updated_at']
    
    def get_variants_count(self, obj):
        return obj.variants.count()
    
    def get_original_variant(self, obj):
        original = obj.variants.filter(is_original=True).first()
        if original:
            return PrototypeVariantSerializer(original).data
        return None

class PrototypeDetailSerializer(PrototypeSerializer):
    variants = PrototypeVariantSerializer(many=True, read_only=True)
    
    class Meta(PrototypeSerializer.Meta):
        fields = PrototypeSerializer.Meta.fields + ['variants']

class DesignProjectSerializer(serializers.ModelSerializer):
    groups = GroupSerializer(many=True, read_only=True)
    prototypes_count = serializers.SerializerMethodField()
    
    class Meta:
        model = DesignProject
        fields = ['id', 'user', 'title', 'description', 'created_at', 'updated_at', 
                 'groups', 'prototypes_count']
        read_only_fields = ['id', 'created_at', 'updated_at', 'user']
    
    def get_prototypes_count(self, obj):
        return obj.prototypes.count()

class DesignProjectDetailSerializer(DesignProjectSerializer):
    prototypes = PrototypeSerializer(many=True, read_only=True)
    
    class Meta(DesignProjectSerializer.Meta):
        fields = DesignProjectSerializer.Meta.fields + ['prototypes'] 

==========

##########
FILE: backend/prototypes/tests.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/tests.py
##########

from django.test import TestCase

# Create your tests here.


==========

##########
FILE: backend/prototypes/urls.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/urls.py
##########

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'design-projects', views.DesignProjectViewSet, basename='design-project')
router.register(r'groups', views.GroupViewSet, basename='group')
router.register(r'prototypes', views.PrototypeViewSet, basename='prototype')
router.register(r'variants', views.PrototypeVariantViewSet, basename='variant')
router.register(r'versions', views.PrototypeVersionViewSet, basename='version')

urlpatterns = [
    path('', include(router.urls)),
    path('design-projects/<uuid:project_id>/prototypes/', views.design_project_prototypes, name='design-project-prototypes'),
    path('groups/<uuid:group_id>/prototypes/', views.group_prototypes, name='group-prototypes'),
    path('generate-prototype/', views.generate_prototype, name='generate-prototype'),
] 

==========

##########
FILE: backend/prototypes/apps.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/apps.py
##########

from django.apps import AppConfig


class PrototypesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'prototypes'
    verbose_name = 'UI Prototypes'


==========

##########
FILE: backend/prototypes/models.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/prototypes/models.py
##########

import uuid
from django.db import models
from appauth.models import AppUser

# Create your models here.

class DesignProject(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(AppUser, on_delete=models.CASCADE, related_name='design_projects')
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title
    
    class Meta:
        ordering = ['-created_at']

class Group(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    design_project = models.ForeignKey(DesignProject, on_delete=models.CASCADE, related_name='groups')
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
    
    class Meta:
        ordering = ['-created_at']

class Prototype(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    design_project = models.ForeignKey(DesignProject, on_delete=models.CASCADE, related_name='prototypes')
    group = models.ForeignKey(Group, on_delete=models.SET_NULL, null=True, blank=True, related_name='prototypes')
    title = models.CharField(max_length=200)
    prompt = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title
    
    class Meta:
        ordering = ['-created_at']

class PrototypeVariant(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    prototype = models.ForeignKey(Prototype, on_delete=models.CASCADE, related_name='variants')
    name = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    is_original = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.prototype.title} - {self.name}"
    
    class Meta:
        ordering = ['-created_at']

class PrototypeVersion(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    variant = models.ForeignKey(PrototypeVariant, on_delete=models.CASCADE, related_name='versions')
    version_number = models.PositiveIntegerField()
    name = models.CharField(max_length=200)
    edit_prompt = models.TextField(blank=True, null=True)
    html_content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.variant.name} - v{self.version_number}: {self.name}"
    
    class Meta:
        ordering = ['version_number']
        unique_together = ['variant', 'version_number']


==========

##########
FILE: backend/aiassistant/__init__.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/__init__.py
##########



==========

##########
FILE: backend/aiassistant/wsgi.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/wsgi.py
##########

"""
WSGI config for aiassistant project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'aiassistant.settings')

application = get_wsgi_application()


==========

##########
FILE: backend/aiassistant/celery.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/celery.py
##########

# celery.py
from __future__ import absolute_import, unicode_literals
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'aiassistant.settings')

app = Celery('your_project_name')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs.
app.autodiscover_tasks()


==========

##########
FILE: backend/aiassistant/urls.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/urls.py
##########

"""
URL configuration for aiassistant project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/v1/auth/", include("appauth.urls")),
    path("api/v1/chat/", include("chat.urls")),
    path("api/v1/prototypes/", include("prototypes.urls")),
]

==========

##########
FILE: backend/aiassistant/asgi.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/asgi.py
##########

"""
ASGI config for aiassistant project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'aiassistant.settings')

application = get_asgi_application()


==========

##########
FILE: backend/aiassistant/settings.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/settings.py
##########

"""
Django settings for aiassistant project.

Generated by 'django-admin startproject' using Django 5.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""
import environ
env = environ.Env()
environ.Env.read_env()
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1',])

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "rest_framework",
    "corsheaders",
    "appauth",
    "knox",
    "chat",
    "social_django",
    "drf_spectacular",
    "storages",
    "prototypes",
]
AUTHENTICATION_BACKENDS = (
    'social_core.backends.open_id.OpenIdAuth',
    'social_core.backends.google.GoogleOAuth2',
    'social_core.backends.google.GoogleOAuth',
    'django.contrib.auth.backends.ModelBackend',
)

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware', 
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'social_django.middleware.SocialAuthExceptionMiddleware',
]
ROOT_URLCONF = 'aiassistant.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


WSGI_APPLICATION = 'aiassistant.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db_local.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# rest framework configuration, with knox for token authentication
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': ('knox.auth.TokenAuthentication',),
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# auth model
AUTH_USER_MODEL = "appauth.AppUser"


SPECTACULAR_SETTINGS = {
    'TITLE': 'Mantice AI Assistant API',
    'DESCRIPTION': 'Your project description',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    # OTHER SETTINGS
}

# knox settings

from datetime import timedelta
from rest_framework.settings import api_settings

REST_KNOX = {
  'SECURE_HASH_ALGORITHM': 'cryptography.hazmat.primitives.hashes.SHA512',
  'AUTH_TOKEN_CHARACTER_LENGTH': 64,
  'TOKEN_TTL': timedelta(weeks=2),
  'USER_SERIALIZER': 'knox.serializers.UserSerializer',
  'TOKEN_LIMIT_PER_USER': None,
  'AUTO_REFRESH': True,
  'EXPIRY_DATETIME_FORMAT': api_settings.DATETIME_FORMAT,
}

BUNDLER_SERVER_URL = "http://localhost:3001"


# AWS S3 Settings
AWS_ACCESS_KEY_ID =  env('AWS_S3_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = env('AWS_S3_SECRET_ACCESS_KEY')
AWS_STORAGE_BUCKET_NAME =  env('AWS_S3_BUCKET_NAME')
AWS_S3_REGION_NAME = env('AWS_S3_BUCKET_REGION')
AWS_S3_FILE_OVERWRITE = False
AWS_DEFAULT_ACL = None
AWS_S3_VERIFY = True

# Make sure AWS_S3_CUSTOM_DOMAIN is set
AWS_S3_CUSTOM_DOMAIN = f'{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com'
# S3 Static settings
STATIC_LOCATION = 'static'
STATIC_URL = f'https://{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com/{STATIC_LOCATION}/'
STATICFILES_STORAGE = 'aiassistant.storage_backends.StaticStorage'

# S3 Media settings
PUBLIC_MEDIA_LOCATION = 'media'
MEDIA_URL = f'https://{AWS_S3_CUSTOM_DOMAIN}/{PUBLIC_MEDIA_LOCATION}/'
DEFAULT_FILE_STORAGE = 'aiassistant.storage_backends.MediaStorage'
PAYSTACK_SECRET_KEY = env('PAYSTACK_SECRET_KEY')

TOKEN_PRICE= 0.01

AWS_BEDROCK_ACCESS_KEY_ID=env("AWS_BEDROCK_ACCESS_KEY_ID")
AWS_BEDROCK_SECRET_ACCESS_KEY=env("AWS_BEDROCK_SECRET_ACCESS_KEY")

FRONTEND_URL = "http://localhost:3000"
SITE_NAME = "Mantice AI"
SUPPORT_EMAIL = env('EMAIL_USER')

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.zoho.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
EMAIL_HOST_USER = env('EMAIL_USER')
EMAIL_HOST_PASSWORD = env('EMAIL_PASSWORD')
DEFAULT_FROM_EMAIL = env('EMAIL_USER')


# CORS Settings
CORS_ALLOW_ALL_ORIGINS = False  # More secure than allowing all origins
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=[])
CORS_ALLOW_CREDENTIALS = True  # Important for sending cookies across origins

# CSRF Settings
CSRF_TRUSTED_ORIGINS = env.list('CSRF_TRUSTED_ORIGINS', default=[])
CSRF_COOKIE_SAMESITE = 'Lax'  # or 'None' if needed, but 'Lax' is more secure
CSRF_COOKIE_HTTPONLY = False  # False because we need to access it from JavaScript
SESSION_COOKIE_SAMESITE = 'Lax'  # Should match CSRF_COOKIE_SAMESITE
CSRF_COOKIE_SECURE = False  # Set to True in production with HTTPS
SESSION_COOKIE_SECURE = False  # Set to True in production with HTTPS

# Cookie settings
CSRF_COOKIE_NAME = 'csrftoken'  # Default value, but good to be explicit




==========

##########
FILE: backend/aiassistant/storage_backends.py
FULL PATH: /home/kelvin/coding/ai/manticeai/myclaude/backend/aiassistant/storage_backends.py
##########

from storages.backends.s3boto3 import S3Boto3Storage

class StaticStorage(S3Boto3Storage):
    location = 'static'
    default_acl = 'public-read'

class MediaStorage(S3Boto3Storage):
    location = 'media'
    default_acl = 'public-read'
    file_overwrite = False

==========
